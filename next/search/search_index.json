{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Frequenz channels","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Channel implementations for Python</p>"},{"location":"#contributing","title":"Contributing","text":"<p>If you want to know how to build this project and contribute to it, please check out the Contributing Guide.</p>"},{"location":"CONTRIBUTING/","title":"Contributing to Frequenz channels","text":""},{"location":"CONTRIBUTING/#build","title":"Build","text":"<p>You can use <code>build</code> to simply build the source and binary distribution:</p> <pre><code>python -m pip install build\npython -m build\n</code></pre>"},{"location":"CONTRIBUTING/#local-development","title":"Local development","text":"<p>You can use editable installs to develop the project locally (it will install all the dependencies too):</p> <pre><code>python -m pip install -e .\n</code></pre> <p>Or you can install all development dependencies (<code>mypy</code>, <code>pylint</code>, <code>pytest</code>, etc.) in one go too: <pre><code>python -m pip install -e .[dev]\n</code></pre></p> <p>If you don't want to install all the dependencies, you can also use <code>nox</code> to run the tests and other checks creating its own virtual environments:</p> <pre><code>python -m pip install .[dev-noxfile]\nnox\n</code></pre> <p>You can also use <code>nox -R</code> to reuse the current testing environment to speed up test at the expense of a higher chance to end up with a dirty test environment.</p>"},{"location":"CONTRIBUTING/#running-tests-checks-individually","title":"Running tests / checks individually","text":"<p>For a better development test cycle you can install the runtime and test dependencies and run <code>pytest</code> manually.</p> <pre><code>python -m pip install .[dev-pytest]  # included in .[dev] too\n# And for example\npytest tests/test_*.py\n</code></pre> <p>Or you can use <code>nox</code>:</p> <pre><code>nox -R -s pytest -- test/test_*.py\n</code></pre> <p>The same appliest to <code>pylint</code> or <code>mypy</code> for example:</p> <pre><code>nox -R -s pylint -- test/test_*.py\nnox -R -s mypy -- test/test_*.py\n</code></pre>"},{"location":"CONTRIBUTING/#building-the-documentation","title":"Building the documentation","text":"<p>To build the documentation, first install the dependencies (if you didn't install all <code>dev</code> dependencies):</p> <pre><code>python -m pip install -e .[dev-mkdocs]\n</code></pre> <p>Then you can build the documentation (it will be written in the <code>site/</code> directory):</p> <pre><code>mkdocs build\n</code></pre> <p>Or you can just serve the documentation without building it using:</p> <pre><code>mkdocs serve\n</code></pre> <p>Your site will be updated live when you change your files (provided that you used <code>pip install -e .</code>, beware of a common pitfall of using <code>pip install</code> without <code>-e</code>, in that case the API reference won't change unless you do a new <code>pip install</code>).</p> <p>To build multi-version documentation, we use mike. If you want to see how the multi-version sites looks like locally, you can use:</p> <pre><code>mike deploy my-version\nmike set-default my-version\nmike serve\n</code></pre> <p><code>mike</code> works in mysterious ways. Some basic information:</p> <ul> <li><code>mike deploy</code> will do a <code>mike build</code> and write the results to your local <code>gh-pages</code> branch. <code>my-version</code> is an arbitrary name for the local version   you want to preview.</li> <li><code>mike set-default</code> is needed so when you serve the documentation, it goes to   your newly produced documentation by default.</li> <li><code>mike serve</code> will serve the contents of your local <code>gh-pages</code> branch. Be   aware that, unlike <code>mkdocs serve</code>, changes to the sources won't be shown   live, as the <code>mike deploy</code> step is needed to refresh them.</li> </ul> <p>Be careful not to use <code>--push</code> with <code>mike deploy</code>, otherwise it will push your local <code>gh-pages</code> branch to the <code>origin</code> remote.</p> <p>That said, if you want to test the actual website in your fork, you can always use <code>mike deploy --push --remote your-fork-remote</code>, and then access the GitHub pages produced for your fork.</p>"},{"location":"CONTRIBUTING/#releasing","title":"Releasing","text":"<p>These are the steps to create a new release:</p> <ol> <li> <p>Get the latest head you want to create a release from.</p> </li> <li> <p>Update the <code>RELEASE_NOTES.md</code> file if it is not complete, up to date, and    remove template comments (<code>&lt;!-- ... -&gt;</code>) and empty sections. Submit a pull    request if an update is needed, wait until it is merged, and update the    latest head you want to create a release from to get the new merged pull    request.</p> </li> <li> <p>Create a new signed tag using the release notes and    a semver compatible version number with a <code>v</code> prefix,    for example:</p> </li> </ol> <pre><code>git tag -s --cleanup=whitespace -F RELEASE_NOTES.md v0.0.1\n</code></pre> <ol> <li> <p>Push the new tag.</p> </li> <li> <p>A GitHub action will test the tag and if all goes well it will create    a GitHub    Release,    and upload a new package to    PyPI    automatically.</p> </li> <li> <p>Once this is done, reset the <code>RELEASE_NOTES.md</code> with the template:</p> </li> </ol> <pre><code>cp .github/RELEASE_NOTES.template.md RELEASE_NOTES.md\n</code></pre> <p>Commit the new release notes and create a PR (this step should be automated    eventually too).</p> <ol> <li>Celebrate!</li> </ol>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>API Reference</li> <li>Contributing</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>conftest</li> <li>frequenz<ul> <li>channels<ul> <li>util</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/conftest/","title":"conftest","text":""},{"location":"reference/conftest/#conftest","title":"<code>conftest</code>","text":"<p>Pytest plugin to validate docstring code examples.</p> <p>Code examples are often wrapped in triple backticks (```) within our docstrings. This plugin extracts these code examples and validates them using pylint.</p>"},{"location":"reference/conftest/#conftest-classes","title":"Classes","text":""},{"location":"reference/conftest/#conftest.CustomPythonCodeBlockParser","title":"<code>conftest.CustomPythonCodeBlockParser</code>","text":"<p>             Bases: <code>CodeBlockParser</code></p> <p>Code block parser that validates extracted code examples using pylint.</p> <p>This parser is a modified version of the default Python code block parser from the Sybil library. It uses pylint to validate the extracted code examples.</p> <p>All code examples are preceded by the original file's import statements as well as an wildcard import of the file itself. This allows us to use the code examples as if they were part of the original file.</p> <p>Additionally, the code example is padded with empty lines to make sure the line numbers are correct.</p> <p>Pylint warnings which are unimportant for code examples are disabled.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/conftest.py</code> <pre><code>class CustomPythonCodeBlockParser(CodeBlockParser):  # type: ignore[misc]\n\"\"\"Code block parser that validates extracted code examples using pylint.\n    This parser is a modified version of the default Python code block parser\n    from the Sybil library.\n    It uses pylint to validate the extracted code examples.\n    All code examples are preceded by the original file's import statements as\n    well as an wildcard import of the file itself.\n    This allows us to use the code examples as if they were part of the original\n    file.\n    Additionally, the code example is padded with empty lines to make sure the\n    line numbers are correct.\n    Pylint warnings which are unimportant for code examples are disabled.\n    \"\"\"\ndef __init__(self) -&gt; None:\n\"\"\"Initialize the parser.\"\"\"\nsuper().__init__(\"python\")\ndef evaluate(self, example: Example) -&gt; None | str:\n\"\"\"Validate the extracted code example using pylint.\n        Args:\n            example: The extracted code example.\n        Returns:\n            None if the code example is valid, otherwise the pylint output.\n        \"\"\"\n# Get the import statements for the original file\nimport_header = get_import_statements(example.document.text)\n# Add a wildcard import of the original file\nimport_header.append(\npath_to_import_statement(Path(os.path.relpath(example.path)))\n)\nimports_code = \"\\n\".join(import_header)\n# Dedent the code example\n# There is also example.parsed that is already prepared, but it has\n# empty lines stripped and thus fucks up the line numbers.\nexample_code = textwrap.dedent(\nexample.document.text[example.start : example.end]\n)\n# Remove first line (the line with the triple backticks)\nexample_code = example_code[example_code.find(\"\\n\") + 1 :]\nexample_with_imports = FORMAT_STRING.format(\ndisable_pylint=PYLINT_DISABLE_COMMENT.format(\"disable\"),\nimports=imports_code,\nenable_pylint=PYLINT_DISABLE_COMMENT.format(\"enable\"),\ncode=example_code,\n)\n# Make sure the line numbers are correct\nsource = pad(\nexample_with_imports,\nexample.line - imports_code.count(\"\\n\") - FORMAT_STRING.count(\"\\n\"),\n)\n# pylint disable parameters\npylint_disable_params = [\n\"missing-module-docstring\",\n\"missing-class-docstring\",\n\"missing-function-docstring\",\n\"reimported\",\n\"unused-variable\",\n\"no-name-in-module\",\n\"await-outside-async\",\n]\nresponse = validate_with_pylint(source, example.path, pylint_disable_params)\nif len(response) &gt; 0:\nresponse_concats = \"\\n\".join(response)\nreturn (\nf\"Pylint validation failed for code example:\\n\"\nf\"{example_with_imports}\\nOutput: {response_concats}\"\n)\nreturn None\n</code></pre>"},{"location":"reference/conftest/#conftest.CustomPythonCodeBlockParser-functions","title":"Functions","text":""},{"location":"reference/conftest/#conftest.CustomPythonCodeBlockParser.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the parser.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/conftest.py</code> <pre><code>def __init__(self) -&gt; None:\n\"\"\"Initialize the parser.\"\"\"\nsuper().__init__(\"python\")\n</code></pre>"},{"location":"reference/conftest/#conftest.CustomPythonCodeBlockParser.evaluate","title":"<code>evaluate(example)</code>","text":"<p>Validate the extracted code example using pylint.</p> PARAMETER  DESCRIPTION <code>example</code> <p>The extracted code example.</p> <p> TYPE: <code>Example</code> </p> RETURNS DESCRIPTION <code>None | str</code> <p>None if the code example is valid, otherwise the pylint output.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/conftest.py</code> <pre><code>def evaluate(self, example: Example) -&gt; None | str:\n\"\"\"Validate the extracted code example using pylint.\n    Args:\n        example: The extracted code example.\n    Returns:\n        None if the code example is valid, otherwise the pylint output.\n    \"\"\"\n# Get the import statements for the original file\nimport_header = get_import_statements(example.document.text)\n# Add a wildcard import of the original file\nimport_header.append(\npath_to_import_statement(Path(os.path.relpath(example.path)))\n)\nimports_code = \"\\n\".join(import_header)\n# Dedent the code example\n# There is also example.parsed that is already prepared, but it has\n# empty lines stripped and thus fucks up the line numbers.\nexample_code = textwrap.dedent(\nexample.document.text[example.start : example.end]\n)\n# Remove first line (the line with the triple backticks)\nexample_code = example_code[example_code.find(\"\\n\") + 1 :]\nexample_with_imports = FORMAT_STRING.format(\ndisable_pylint=PYLINT_DISABLE_COMMENT.format(\"disable\"),\nimports=imports_code,\nenable_pylint=PYLINT_DISABLE_COMMENT.format(\"enable\"),\ncode=example_code,\n)\n# Make sure the line numbers are correct\nsource = pad(\nexample_with_imports,\nexample.line - imports_code.count(\"\\n\") - FORMAT_STRING.count(\"\\n\"),\n)\n# pylint disable parameters\npylint_disable_params = [\n\"missing-module-docstring\",\n\"missing-class-docstring\",\n\"missing-function-docstring\",\n\"reimported\",\n\"unused-variable\",\n\"no-name-in-module\",\n\"await-outside-async\",\n]\nresponse = validate_with_pylint(source, example.path, pylint_disable_params)\nif len(response) &gt; 0:\nresponse_concats = \"\\n\".join(response)\nreturn (\nf\"Pylint validation failed for code example:\\n\"\nf\"{example_with_imports}\\nOutput: {response_concats}\"\n)\nreturn None\n</code></pre>"},{"location":"reference/conftest/#conftest-functions","title":"Functions","text":""},{"location":"reference/conftest/#conftest.get_import_statements","title":"<code>conftest.get_import_statements(code)</code>","text":"<p>Get all import statements from a given code string.</p> PARAMETER  DESCRIPTION <code>code</code> <p>The code to extract import statements from.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list[str]</code> <p>A list of import statements.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/conftest.py</code> <pre><code>def get_import_statements(code: str) -&gt; list[str]:\n\"\"\"Get all import statements from a given code string.\n    Args:\n        code: The code to extract import statements from.\n    Returns:\n        A list of import statements.\n    \"\"\"\ntree = ast.parse(code)\nimport_statements: list[str] = []\nfor node in ast.walk(tree):\nif isinstance(node, (ast.Import, ast.ImportFrom)):\nimport_statement = ast.get_source_segment(code, node)\nassert import_statement is not None\nimport_statements.append(import_statement)\nreturn import_statements\n</code></pre>"},{"location":"reference/conftest/#conftest.path_to_import_statement","title":"<code>conftest.path_to_import_statement(path)</code>","text":"<p>Convert a path to a Python file to an import statement.</p> PARAMETER  DESCRIPTION <code>path</code> <p>The path to convert.</p> <p> TYPE: <code>Path</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The import statement.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the path does not point to a Python file.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/conftest.py</code> <pre><code>def path_to_import_statement(path: Path) -&gt; str:\n\"\"\"Convert a path to a Python file to an import statement.\n    Args:\n        path: The path to convert.\n    Returns:\n        The import statement.\n    Raises:\n        ValueError: If the path does not point to a Python file.\n    \"\"\"\n# Make the path relative to the present working directory\nif path.is_absolute():\npath = path.relative_to(Path.cwd())\n# Check if the path is a Python file\nif path.suffix != \".py\":\nraise ValueError(\"Path must point to a Python file (.py)\")\n# Remove 'src' prefix if present\nparts = path.parts\nif parts[0] == \"src\":\nparts = parts[1:]\n# Remove the '.py' extension and join parts with '.'\nmodule_path = \".\".join(parts)[:-3]\n# Create the import statement\nimport_statement = f\"from {module_path} import *\"\nreturn import_statement\n</code></pre>"},{"location":"reference/conftest/#conftest.validate_with_pylint","title":"<code>conftest.validate_with_pylint(code_example, path, disable_params)</code>","text":"<p>Validate a code example using pylint.</p> PARAMETER  DESCRIPTION <code>code_example</code> <p>The code example to validate.</p> <p> TYPE: <code>str</code> </p> <code>path</code> <p>The path to the original file.</p> <p> TYPE: <code>str</code> </p> <code>disable_params</code> <p>The pylint disable parameters.</p> <p> TYPE: <code>list[str]</code> </p> RETURNS DESCRIPTION <code>list[str]</code> <p>A list of pylint messages.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/conftest.py</code> <pre><code>def validate_with_pylint(\ncode_example: str, path: str, disable_params: list[str]\n) -&gt; list[str]:\n\"\"\"Validate a code example using pylint.\n    Args:\n        code_example: The code example to validate.\n        path: The path to the original file.\n        disable_params: The pylint disable parameters.\n    Returns:\n        A list of pylint messages.\n    \"\"\"\ntry:\npylint_command = [\n\"pylint\",\n\"--disable\",\n\",\".join(disable_params),\n\"--from-stdin\",\npath,\n]\nsubprocess.run(\npylint_command,\ninput=code_example,\ntext=True,\ncapture_output=True,\ncheck=True,\n)\nexcept subprocess.CalledProcessError as exception:\noutput = exception.output\nassert isinstance(output, str)\nreturn output.splitlines()\nreturn []\n</code></pre>"},{"location":"reference/frequenz/channels/","title":"channels","text":""},{"location":"reference/frequenz/channels/#frequenz.channels","title":"<code>frequenz.channels</code>","text":"<p>Frequenz Channels.</p> <p>This package contains channel implementations.</p> <p>Channels:</p> <ul> <li> <p>Anycast: A channel that supports multiple   senders and multiple receivers.  A message sent through a sender will be   received by exactly one receiver.</p> </li> <li> <p>Bidirectional: A channel providing   a <code>client</code> and a <code>service</code> handle to send and receive bidirectionally.</p> </li> <li> <p>Broadcast: A channel to broadcast messages   from multiple senders to multiple receivers. Each message sent through any of   the senders is received by all of the receivers.</p> </li> </ul> <p>Other base classes:</p> <ul> <li> <p>Peekable: An object to allow users to get   a peek at the latest value in the channel, without consuming anything.</p> </li> <li> <p>Receiver: An object that can wait for and   consume messages from a channel.</p> </li> <li> <p>Sender: An object that can send messages to   a channel.</p> </li> </ul> <p>Utilities:</p> <ul> <li>util: A module with utilities, like special   receivers that implement timers, file watchers, merge receivers, or wait for   messages in multiple channels.</li> </ul> <p>Exception classes:</p> <ul> <li> <p>Error: Base class for all errors in this   library.</p> </li> <li> <p>ChannelError: Base class for all errors   related to channels.</p> </li> <li> <p>ChannelClosedError: Error raised when   trying to operate (send, receive, etc.) through a closed channel.</p> </li> <li> <p>SenderError: Base class for all errors   related to senders.</p> </li> <li> <p>ReceiverError: Base class for all errors   related to receivers.</p> </li> <li> <p>ReceiverStoppedError: A receiver   stopped producing messages.</p> </li> <li> <p>ReceiverInvalidatedError:   A receiver is not longer valid (for example if it was converted into   a peekable.</p> </li> </ul>"},{"location":"reference/frequenz/channels/#frequenz.channels-classes","title":"Classes","text":""},{"location":"reference/frequenz/channels/#frequenz.channels.Anycast","title":"<code>frequenz.channels.Anycast</code>","text":"<p>             Bases: <code>Generic[T]</code></p> <p>A channel for sending data across async tasks.</p> <p>Anycast channels support multiple senders and multiple receivers.  A message sent through a sender will be received by exactly one receiver.</p> <p>In cases where each message need to be received by every receiver, a Broadcast channel may be used.</p> <p>Uses an deque internally, so Anycast channels are not thread-safe.</p> <p>When there are multiple channel receivers, they can be awaited simultaneously using select, Merge or MergeNamed.</p> Example <pre><code>async def send(sender: channel.Sender) -&gt; None:\nwhile True:\nnext = random.randint(3, 17)\nprint(f\"sending: {next}\")\nawait sender.send(next)\nasync def recv(id: int, receiver: channel.Receiver) -&gt; None:\nwhile True:\nnext = await receiver.receive()\nprint(f\"receiver_{id} received {next}\")\nawait asyncio.sleep(0.1) # sleep (or work) with the data\nacast = channel.Anycast()\nsender = acast.new_sender()\nreceiver_1 = acast.new_receiver()\nasyncio.create_task(send(sender))\nawait recv(1, receiver_1)\n</code></pre> <p>Check the <code>tests</code> and <code>benchmarks</code> directories for more examples.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_anycast.py</code> <pre><code>class Anycast(Generic[T]):\n\"\"\"A channel for sending data across async tasks.\n    Anycast channels support multiple senders and multiple receivers.  A message sent\n    through a sender will be received by exactly one receiver.\n    In cases where each message need to be received by every receiver, a\n    [Broadcast][frequenz.channels.Broadcast] channel may be used.\n    Uses an [deque][collections.deque] internally, so Anycast channels are not\n    thread-safe.\n    When there are multiple channel receivers, they can be awaited\n    simultaneously using [select][frequenz.channels.util.select],\n    [Merge][frequenz.channels.util.Merge] or\n    [MergeNamed][frequenz.channels.util.MergeNamed].\n    Example:\n        ``` python\n        async def send(sender: channel.Sender) -&gt; None:\n            while True:\n                next = random.randint(3, 17)\n                print(f\"sending: {next}\")\n                await sender.send(next)\n        async def recv(id: int, receiver: channel.Receiver) -&gt; None:\n            while True:\n                next = await receiver.receive()\n                print(f\"receiver_{id} received {next}\")\n                await asyncio.sleep(0.1) # sleep (or work) with the data\n        acast = channel.Anycast()\n        sender = acast.new_sender()\n        receiver_1 = acast.new_receiver()\n        asyncio.create_task(send(sender))\n        await recv(1, receiver_1)\n        ```\n        Check the `tests` and `benchmarks` directories for more examples.\n    \"\"\"\ndef __init__(self, maxsize: int = 10) -&gt; None:\n\"\"\"Create an Anycast channel.\n        Args:\n            maxsize: Size of the channel's buffer.\n        \"\"\"\nself.limit: int = maxsize\nself.deque: Deque[T] = deque(maxlen=maxsize)\nself.send_cv: Condition = Condition()\nself.recv_cv: Condition = Condition()\nself.closed: bool = False\nasync def close(self) -&gt; None:\n\"\"\"Close the channel.\n        Any further attempts to [send()][frequenz.channels.Sender.send] data\n        will return `False`.\n        Receivers will still be able to drain the pending items on the channel,\n        but after that, subsequent\n        [receive()][frequenz.channels.Receiver.receive] calls will return `None`\n        immediately.\n        \"\"\"\nself.closed = True\nasync with self.send_cv:\nself.send_cv.notify_all()\nasync with self.recv_cv:\nself.recv_cv.notify_all()\ndef new_sender(self) -&gt; Sender[T]:\n\"\"\"Create a new sender.\n        Returns:\n            A Sender instance attached to the Anycast channel.\n        \"\"\"\nreturn Sender(self)\ndef new_receiver(self) -&gt; Receiver[T]:\n\"\"\"Create a new receiver.\n        Returns:\n            A Receiver instance attached to the Anycast channel.\n        \"\"\"\nreturn Receiver(self)\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Anycast-functions","title":"Functions","text":""},{"location":"reference/frequenz/channels/#frequenz.channels.Anycast.__init__","title":"<code>__init__(maxsize=10)</code>","text":"<p>Create an Anycast channel.</p> PARAMETER  DESCRIPTION <code>maxsize</code> <p>Size of the channel's buffer.</p> <p> TYPE: <code>int</code> DEFAULT: <code>10</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_anycast.py</code> <pre><code>def __init__(self, maxsize: int = 10) -&gt; None:\n\"\"\"Create an Anycast channel.\n    Args:\n        maxsize: Size of the channel's buffer.\n    \"\"\"\nself.limit: int = maxsize\nself.deque: Deque[T] = deque(maxlen=maxsize)\nself.send_cv: Condition = Condition()\nself.recv_cv: Condition = Condition()\nself.closed: bool = False\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Anycast.close","title":"<code>close()</code>  <code>async</code>","text":"<p>Close the channel.</p> <p>Any further attempts to send() data will return <code>False</code>.</p> <p>Receivers will still be able to drain the pending items on the channel, but after that, subsequent receive() calls will return <code>None</code> immediately.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_anycast.py</code> <pre><code>async def close(self) -&gt; None:\n\"\"\"Close the channel.\n    Any further attempts to [send()][frequenz.channels.Sender.send] data\n    will return `False`.\n    Receivers will still be able to drain the pending items on the channel,\n    but after that, subsequent\n    [receive()][frequenz.channels.Receiver.receive] calls will return `None`\n    immediately.\n    \"\"\"\nself.closed = True\nasync with self.send_cv:\nself.send_cv.notify_all()\nasync with self.recv_cv:\nself.recv_cv.notify_all()\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Anycast.new_receiver","title":"<code>new_receiver()</code>","text":"<p>Create a new receiver.</p> RETURNS DESCRIPTION <code>Receiver[T]</code> <p>A Receiver instance attached to the Anycast channel.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_anycast.py</code> <pre><code>def new_receiver(self) -&gt; Receiver[T]:\n\"\"\"Create a new receiver.\n    Returns:\n        A Receiver instance attached to the Anycast channel.\n    \"\"\"\nreturn Receiver(self)\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Anycast.new_sender","title":"<code>new_sender()</code>","text":"<p>Create a new sender.</p> RETURNS DESCRIPTION <code>Sender[T]</code> <p>A Sender instance attached to the Anycast channel.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_anycast.py</code> <pre><code>def new_sender(self) -&gt; Sender[T]:\n\"\"\"Create a new sender.\n    Returns:\n        A Sender instance attached to the Anycast channel.\n    \"\"\"\nreturn Sender(self)\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Bidirectional","title":"<code>frequenz.channels.Bidirectional</code>","text":"<p>             Bases: <code>Generic[T, U]</code></p> <p>A wrapper class for simulating bidirectional channels.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_bidirectional.py</code> <pre><code>class Bidirectional(Generic[T, U]):\n\"\"\"A wrapper class for simulating bidirectional channels.\"\"\"\nclass Handle(Sender[V], Receiver[W]):\n\"\"\"A handle to a [Bidirectional][frequenz.channels.Bidirectional] instance.\n        It can be used to send/receive values between the client and service.\n        \"\"\"\ndef __init__(\nself,\nchannel: Bidirectional[V, W] | Bidirectional[W, V],\nsender: Sender[V],\nreceiver: Receiver[W],\n) -&gt; None:\n\"\"\"Create a `Bidirectional.Handle` instance.\n            Args:\n                channel: The underlying channel.\n                sender: A sender to send values with.\n                receiver: A receiver to receive values from.\n            \"\"\"\nself._chan = channel\nself._sender = sender\nself._receiver = receiver\nasync def send(self, msg: V) -&gt; None:\n\"\"\"Send a value to the other side.\n            Args:\n                msg: The value to send.\n            Raises:\n                SenderError: if the underlying channel was closed.\n                    A [ChannelClosedError][frequenz.channels.ChannelClosedError]\n                    is set as the cause.\n            \"\"\"\ntry:\nawait self._sender.send(msg)\nexcept SenderError as err:\n# If this comes from a channel error, then we inject another\n# ChannelError having the information about the Bidirectional\n# channel to hide (at least partially) the underlaying\n# Broadcast channels we use.\nif isinstance(err.__cause__, ChannelError):\nthis_chan_error = ChannelError(\nf\"Error in the underlying channel {err.__cause__.channel}: {err.__cause__}\",\nself._chan,  # pylint: disable=protected-access\n)\nthis_chan_error.__cause__ = err.__cause__\nerr.__cause__ = this_chan_error\nraise err\nasync def ready(self) -&gt; bool:\n\"\"\"Wait until the receiver is ready with a value or an error.\n            Once a call to `ready()` has finished, the value should be read with\n            a call to `consume()` (`receive()` or iterated over). The receiver will\n            remain ready (this method will return immediately) until it is\n            consumed.\n            Returns:\n                Whether the receiver is still active.\n            \"\"\"\nreturn await self._receiver.ready()  # pylint: disable=protected-access\ndef consume(self) -&gt; W:\n\"\"\"Return the latest value once `_ready` is complete.\n            Returns:\n                The next value that was received.\n            Raises:\n                ReceiverStoppedError: if there is some problem with the receiver.\n                ReceiverError: if there is some problem with the receiver.\n            # noqa: DAR401 err (https://github.com/terrencepreilly/darglint/issues/181)\n            \"\"\"\ntry:\nreturn self._receiver.consume()  # pylint: disable=protected-access\nexcept ReceiverError as err:\n# If this comes from a channel error, then we inject another\n# ChannelError having the information about the Bidirectional\n# channel to hide (at least partially) the underlaying\n# Broadcast channels we use.\nif isinstance(err.__cause__, ChannelError):\nthis_chan_error = ChannelError(\nf\"Error in the underlying channel {err.__cause__.channel}: {err.__cause__}\",\nself._chan,  # pylint: disable=protected-access\n)\nthis_chan_error.__cause__ = err.__cause__\nerr.__cause__ = this_chan_error\nraise err\ndef __init__(self, client_id: str, service_id: str) -&gt; None:\n\"\"\"Create a `Bidirectional` instance.\n        Args:\n            client_id: A name for the client, used to name the channels.\n            service_id: A name for the service end of the channels.\n        \"\"\"\nself._client_id = client_id\nself._request_channel: Broadcast[T] = Broadcast(f\"req_{service_id}_{client_id}\")\nself._response_channel: Broadcast[U] = Broadcast(\nf\"resp_{service_id}_{client_id}\"\n)\nself._client_handle = Bidirectional.Handle(\nself,\nself._request_channel.new_sender(),\nself._response_channel.new_receiver(),\n)\nself._service_handle = Bidirectional.Handle(\nself,\nself._response_channel.new_sender(),\nself._request_channel.new_receiver(),\n)\n@property\ndef client_handle(self) -&gt; Bidirectional.Handle[T, U]:\n\"\"\"Get a `Handle` for the client side to use.\n        Returns:\n            Object to send/receive messages with.\n        \"\"\"\nreturn self._client_handle\n@property\ndef service_handle(self) -&gt; Bidirectional.Handle[U, T]:\n\"\"\"Get a `Handle` for the service side to use.\n        Returns:\n            Object to send/receive messages with.\n        \"\"\"\nreturn self._service_handle\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Bidirectional-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/channels/#frequenz.channels.Bidirectional.client_handle","title":"<code>client_handle: Bidirectional.Handle[T, U]</code>  <code>property</code>","text":"<p>Get a <code>Handle</code> for the client side to use.</p> RETURNS DESCRIPTION <code>Bidirectional.Handle[T, U]</code> <p>Object to send/receive messages with.</p>"},{"location":"reference/frequenz/channels/#frequenz.channels.Bidirectional.service_handle","title":"<code>service_handle: Bidirectional.Handle[U, T]</code>  <code>property</code>","text":"<p>Get a <code>Handle</code> for the service side to use.</p> RETURNS DESCRIPTION <code>Bidirectional.Handle[U, T]</code> <p>Object to send/receive messages with.</p>"},{"location":"reference/frequenz/channels/#frequenz.channels.Bidirectional-classes","title":"Classes","text":""},{"location":"reference/frequenz/channels/#frequenz.channels.Bidirectional.Handle","title":"<code>Handle</code>","text":"<p>             Bases: <code>Sender[V]</code>, <code>Receiver[W]</code></p> <p>A handle to a Bidirectional instance.</p> <p>It can be used to send/receive values between the client and service.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_bidirectional.py</code> <pre><code>class Handle(Sender[V], Receiver[W]):\n\"\"\"A handle to a [Bidirectional][frequenz.channels.Bidirectional] instance.\n    It can be used to send/receive values between the client and service.\n    \"\"\"\ndef __init__(\nself,\nchannel: Bidirectional[V, W] | Bidirectional[W, V],\nsender: Sender[V],\nreceiver: Receiver[W],\n) -&gt; None:\n\"\"\"Create a `Bidirectional.Handle` instance.\n        Args:\n            channel: The underlying channel.\n            sender: A sender to send values with.\n            receiver: A receiver to receive values from.\n        \"\"\"\nself._chan = channel\nself._sender = sender\nself._receiver = receiver\nasync def send(self, msg: V) -&gt; None:\n\"\"\"Send a value to the other side.\n        Args:\n            msg: The value to send.\n        Raises:\n            SenderError: if the underlying channel was closed.\n                A [ChannelClosedError][frequenz.channels.ChannelClosedError]\n                is set as the cause.\n        \"\"\"\ntry:\nawait self._sender.send(msg)\nexcept SenderError as err:\n# If this comes from a channel error, then we inject another\n# ChannelError having the information about the Bidirectional\n# channel to hide (at least partially) the underlaying\n# Broadcast channels we use.\nif isinstance(err.__cause__, ChannelError):\nthis_chan_error = ChannelError(\nf\"Error in the underlying channel {err.__cause__.channel}: {err.__cause__}\",\nself._chan,  # pylint: disable=protected-access\n)\nthis_chan_error.__cause__ = err.__cause__\nerr.__cause__ = this_chan_error\nraise err\nasync def ready(self) -&gt; bool:\n\"\"\"Wait until the receiver is ready with a value or an error.\n        Once a call to `ready()` has finished, the value should be read with\n        a call to `consume()` (`receive()` or iterated over). The receiver will\n        remain ready (this method will return immediately) until it is\n        consumed.\n        Returns:\n            Whether the receiver is still active.\n        \"\"\"\nreturn await self._receiver.ready()  # pylint: disable=protected-access\ndef consume(self) -&gt; W:\n\"\"\"Return the latest value once `_ready` is complete.\n        Returns:\n            The next value that was received.\n        Raises:\n            ReceiverStoppedError: if there is some problem with the receiver.\n            ReceiverError: if there is some problem with the receiver.\n        # noqa: DAR401 err (https://github.com/terrencepreilly/darglint/issues/181)\n        \"\"\"\ntry:\nreturn self._receiver.consume()  # pylint: disable=protected-access\nexcept ReceiverError as err:\n# If this comes from a channel error, then we inject another\n# ChannelError having the information about the Bidirectional\n# channel to hide (at least partially) the underlaying\n# Broadcast channels we use.\nif isinstance(err.__cause__, ChannelError):\nthis_chan_error = ChannelError(\nf\"Error in the underlying channel {err.__cause__.channel}: {err.__cause__}\",\nself._chan,  # pylint: disable=protected-access\n)\nthis_chan_error.__cause__ = err.__cause__\nerr.__cause__ = this_chan_error\nraise err\n</code></pre> Functions\u00a4 <code>__aiter__()</code> \u00a4 <p>Initialize the async iterator over received values.</p> RETURNS DESCRIPTION <code>Receiver[T]</code> <p><code>self</code>, since no extra setup is needed for the iterator.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_base_classes.py</code> <pre><code>def __aiter__(self) -&gt; Receiver[T]:\n\"\"\"Initialize the async iterator over received values.\n    Returns:\n        `self`, since no extra setup is needed for the iterator.\n    \"\"\"\nreturn self\n</code></pre> <code>__anext__()</code> <code>async</code> \u00a4 <p>Await the next value in the async iteration over received values.</p> RETURNS DESCRIPTION <code>T</code> <p>The next value received.</p> RAISES DESCRIPTION <code>StopAsyncIteration</code> <p>if the receiver stopped producing messages.</p> <code>ReceiverError</code> <p>if there is some problem with the receiver.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_base_classes.py</code> <pre><code>async def __anext__(self) -&gt; T:\n\"\"\"Await the next value in the async iteration over received values.\n    Returns:\n        The next value received.\n    Raises:\n        StopAsyncIteration: if the receiver stopped producing messages.\n        ReceiverError: if there is some problem with the receiver.\n    \"\"\"\ntry:\nawait self.ready()\nreturn self.consume()\nexcept ReceiverStoppedError as exc:\nraise StopAsyncIteration() from exc\n</code></pre> <code>__init__(channel, sender, receiver)</code> \u00a4 <p>Create a <code>Bidirectional.Handle</code> instance.</p> PARAMETER  DESCRIPTION <code>channel</code> <p>The underlying channel.</p> <p> TYPE: <code>Bidirectional[V, W] | Bidirectional[W, V]</code> </p> <code>sender</code> <p>A sender to send values with.</p> <p> TYPE: <code>Sender[V]</code> </p> <code>receiver</code> <p>A receiver to receive values from.</p> <p> TYPE: <code>Receiver[W]</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_bidirectional.py</code> <pre><code>def __init__(\nself,\nchannel: Bidirectional[V, W] | Bidirectional[W, V],\nsender: Sender[V],\nreceiver: Receiver[W],\n) -&gt; None:\n\"\"\"Create a `Bidirectional.Handle` instance.\n    Args:\n        channel: The underlying channel.\n        sender: A sender to send values with.\n        receiver: A receiver to receive values from.\n    \"\"\"\nself._chan = channel\nself._sender = sender\nself._receiver = receiver\n</code></pre> <code>consume()</code> \u00a4 <p>Return the latest value once <code>_ready</code> is complete.</p> RETURNS DESCRIPTION <code>W</code> <p>The next value that was received.</p> RAISES DESCRIPTION <code>ReceiverStoppedError</code> <p>if there is some problem with the receiver.</p> <code>ReceiverError</code> <p>if there is some problem with the receiver.</p> <code>into_peekable()</code> \u00a4 <p>Convert the <code>Receiver</code> implementation into a <code>Peekable</code>.</p> <p>Once this function has been called, the receiver will no longer be usable, and calling <code>receive</code> on the receiver will raise an exception.</p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>when a <code>Receiver</code> implementation doesn't have a custom <code>into_peekable</code> implementation.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_base_classes.py</code> <pre><code>def into_peekable(self) -&gt; Peekable[T]:\n\"\"\"Convert the `Receiver` implementation into a `Peekable`.\n    Once this function has been called, the receiver will no longer be\n    usable, and calling `receive` on the receiver will raise an exception.\n    Raises:\n        NotImplementedError: when a `Receiver` implementation doesn't have\n            a custom `into_peekable` implementation.\n    \"\"\"\nraise NotImplementedError(\"This receiver does not implement `into_peekable`\")\n</code></pre> <code>map(call)</code> \u00a4 <p>Return a receiver with <code>call</code> applied on incoming messages.</p> PARAMETER  DESCRIPTION <code>call</code> <p>function to apply on incoming messages.</p> <p> TYPE: <code>Callable[[T], U]</code> </p> RETURNS DESCRIPTION <code>Receiver[U]</code> <p>A <code>Receiver</code> to read results of the given function from.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_base_classes.py</code> <pre><code>def map(self, call: Callable[[T], U]) -&gt; Receiver[U]:\n\"\"\"Return a receiver with `call` applied on incoming messages.\n    Args:\n        call: function to apply on incoming messages.\n    Returns:\n        A `Receiver` to read results of the given function from.\n    \"\"\"\nreturn _Map(self, call)\n</code></pre> <code>ready()</code> <code>async</code> \u00a4 <p>Wait until the receiver is ready with a value or an error.</p> <p>Once a call to <code>ready()</code> has finished, the value should be read with a call to <code>consume()</code> (<code>receive()</code> or iterated over). The receiver will remain ready (this method will return immediately) until it is consumed.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the receiver is still active.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_bidirectional.py</code> <pre><code>async def ready(self) -&gt; bool:\n\"\"\"Wait until the receiver is ready with a value or an error.\n    Once a call to `ready()` has finished, the value should be read with\n    a call to `consume()` (`receive()` or iterated over). The receiver will\n    remain ready (this method will return immediately) until it is\n    consumed.\n    Returns:\n        Whether the receiver is still active.\n    \"\"\"\nreturn await self._receiver.ready()  # pylint: disable=protected-access\n</code></pre> <code>receive()</code> <code>async</code> \u00a4 <p>Receive a message from the channel.</p> RETURNS DESCRIPTION <code>T</code> <p>The received message.</p> RAISES DESCRIPTION <code>ReceiverStoppedError</code> <p>if there is some problem with the receiver.</p> <code>ReceiverError</code> <p>if there is some problem with the receiver.</p> <code>send(msg)</code> <code>async</code> \u00a4 <p>Send a value to the other side.</p> PARAMETER  DESCRIPTION <code>msg</code> <p>The value to send.</p> <p> TYPE: <code>V</code> </p> RAISES DESCRIPTION <code>SenderError</code> <p>if the underlying channel was closed. A ChannelClosedError is set as the cause.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_bidirectional.py</code> <pre><code>async def send(self, msg: V) -&gt; None:\n\"\"\"Send a value to the other side.\n    Args:\n        msg: The value to send.\n    Raises:\n        SenderError: if the underlying channel was closed.\n            A [ChannelClosedError][frequenz.channels.ChannelClosedError]\n            is set as the cause.\n    \"\"\"\ntry:\nawait self._sender.send(msg)\nexcept SenderError as err:\n# If this comes from a channel error, then we inject another\n# ChannelError having the information about the Bidirectional\n# channel to hide (at least partially) the underlaying\n# Broadcast channels we use.\nif isinstance(err.__cause__, ChannelError):\nthis_chan_error = ChannelError(\nf\"Error in the underlying channel {err.__cause__.channel}: {err.__cause__}\",\nself._chan,  # pylint: disable=protected-access\n)\nthis_chan_error.__cause__ = err.__cause__\nerr.__cause__ = this_chan_error\nraise err\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Bidirectional.Handle.consume--noqa-dar401-err-httpsgithubcomterrencepreillydarglintissues181","title":"noqa: DAR401 err (https://github.com/terrencepreilly/darglint/issues/181)","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_bidirectional.py</code> <pre><code>def consume(self) -&gt; W:\n\"\"\"Return the latest value once `_ready` is complete.\n    Returns:\n        The next value that was received.\n    Raises:\n        ReceiverStoppedError: if there is some problem with the receiver.\n        ReceiverError: if there is some problem with the receiver.\n    # noqa: DAR401 err (https://github.com/terrencepreilly/darglint/issues/181)\n    \"\"\"\ntry:\nreturn self._receiver.consume()  # pylint: disable=protected-access\nexcept ReceiverError as err:\n# If this comes from a channel error, then we inject another\n# ChannelError having the information about the Bidirectional\n# channel to hide (at least partially) the underlaying\n# Broadcast channels we use.\nif isinstance(err.__cause__, ChannelError):\nthis_chan_error = ChannelError(\nf\"Error in the underlying channel {err.__cause__.channel}: {err.__cause__}\",\nself._chan,  # pylint: disable=protected-access\n)\nthis_chan_error.__cause__ = err.__cause__\nerr.__cause__ = this_chan_error\nraise err\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Bidirectional.Handle.receive--noqa-dar401-cause-httpsgithubcomterrencepreillydarglintissues181","title":"noqa: DAR401 cause (https://github.com/terrencepreilly/darglint/issues/181)","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_base_classes.py</code> <pre><code>async def receive(self) -&gt; T:\n\"\"\"Receive a message from the channel.\n    Returns:\n        The received message.\n    Raises:\n        ReceiverStoppedError: if there is some problem with the receiver.\n        ReceiverError: if there is some problem with the receiver.\n    # noqa: DAR401 __cause__ (https://github.com/terrencepreilly/darglint/issues/181)\n    \"\"\"\ntry:\nreceived = await self.__anext__()  # pylint: disable=unnecessary-dunder-call\nexcept StopAsyncIteration as exc:\n# If we already had a cause and it was the receiver was stopped,\n# then reuse that error, as StopAsyncIteration is just an artifact\n# introduced by __anext__.\nif (\nisinstance(exc.__cause__, ReceiverStoppedError)\n# pylint is not smart enough to figure out we checked above\n# this is a ReceiverStoppedError and thus it does have\n# a receiver member\nand exc.__cause__.receiver is self  # pylint: disable=no-member\n):\nraise exc.__cause__\nraise ReceiverStoppedError(self) from exc\nreturn received\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Bidirectional-functions","title":"Functions","text":""},{"location":"reference/frequenz/channels/#frequenz.channels.Bidirectional.__init__","title":"<code>__init__(client_id, service_id)</code>","text":"<p>Create a <code>Bidirectional</code> instance.</p> PARAMETER  DESCRIPTION <code>client_id</code> <p>A name for the client, used to name the channels.</p> <p> TYPE: <code>str</code> </p> <code>service_id</code> <p>A name for the service end of the channels.</p> <p> TYPE: <code>str</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_bidirectional.py</code> <pre><code>def __init__(self, client_id: str, service_id: str) -&gt; None:\n\"\"\"Create a `Bidirectional` instance.\n    Args:\n        client_id: A name for the client, used to name the channels.\n        service_id: A name for the service end of the channels.\n    \"\"\"\nself._client_id = client_id\nself._request_channel: Broadcast[T] = Broadcast(f\"req_{service_id}_{client_id}\")\nself._response_channel: Broadcast[U] = Broadcast(\nf\"resp_{service_id}_{client_id}\"\n)\nself._client_handle = Bidirectional.Handle(\nself,\nself._request_channel.new_sender(),\nself._response_channel.new_receiver(),\n)\nself._service_handle = Bidirectional.Handle(\nself,\nself._response_channel.new_sender(),\nself._request_channel.new_receiver(),\n)\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Broadcast","title":"<code>frequenz.channels.Broadcast</code>","text":"<p>             Bases: <code>Generic[T]</code></p> <p>A channel to broadcast messages to multiple receivers.</p> <p><code>Broadcast</code> channels can have multiple senders and multiple receivers. Each message sent through any of the senders is received by all of the receivers.</p> <p>Internally, a broadcast receiver's buffer is implemented with just append/pop operations on either side of a deque, which are thread-safe.  Because of this, <code>Broadcast</code> channels are thread-safe.</p> <p>When there are multiple channel receivers, they can be awaited simultaneously using select, Merge or MergeNamed.</p> Example <pre><code>async def send(sender: channel.Sender) -&gt; None:\nwhile True:\nnext = random.randint(3, 17)\nprint(f\"sending: {next}\")\nawait sender.send(next)\nasync def recv(id: int, receiver: channel.Receiver) -&gt; None:\nwhile True:\nnext = await receiver.receive()\nprint(f\"receiver_{id} received {next}\")\nawait asyncio.sleep(0.1) # sleep (or work) with the data\nbcast = channel.Broadcast()\nsender = bcast.new_sender()\nreceiver_1 = bcast.new_receiver()\nasyncio.create_task(send(sender))\nawait recv(1, receiver_1)\n</code></pre> <p>Check the <code>tests</code> and <code>benchmarks</code> directories for more examples.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_broadcast.py</code> <pre><code>class Broadcast(Generic[T]):\n\"\"\"A channel to broadcast messages to multiple receivers.\n    `Broadcast` channels can have multiple senders and multiple receivers. Each\n    message sent through any of the senders is received by all of the\n    receivers.\n    Internally, a broadcast receiver's buffer is implemented with just\n    append/pop operations on either side of a [deque][collections.deque], which\n    are thread-safe.  Because of this, `Broadcast` channels are thread-safe.\n    When there are multiple channel receivers, they can be awaited\n    simultaneously using [select][frequenz.channels.util.select],\n    [Merge][frequenz.channels.util.Merge] or\n    [MergeNamed][frequenz.channels.util.MergeNamed].\n    Example:\n        ``` python\n        async def send(sender: channel.Sender) -&gt; None:\n            while True:\n                next = random.randint(3, 17)\n                print(f\"sending: {next}\")\n                await sender.send(next)\n        async def recv(id: int, receiver: channel.Receiver) -&gt; None:\n            while True:\n                next = await receiver.receive()\n                print(f\"receiver_{id} received {next}\")\n                await asyncio.sleep(0.1) # sleep (or work) with the data\n        bcast = channel.Broadcast()\n        sender = bcast.new_sender()\n        receiver_1 = bcast.new_receiver()\n        asyncio.create_task(send(sender))\n        await recv(1, receiver_1)\n        ```\n        Check the `tests` and `benchmarks` directories for more examples.\n    \"\"\"\ndef __init__(self, name: str, resend_latest: bool = False) -&gt; None:\n\"\"\"Create a Broadcast channel.\n        Args:\n            name: A name for the broadcast channel, typically based on the type\n                of data sent through it.  Used to identify the channel in the\n                logs.\n            resend_latest: When True, every time a new receiver is created with\n                `new_receiver`, it will automatically get sent the latest value\n                on the channel.  This allows new receivers on slow streams to\n                get the latest value as soon as they are created, without having\n                to wait for the next message on the channel to arrive.\n        \"\"\"\nself.name: str = name\nself._resend_latest = resend_latest\nself.recv_cv: Condition = Condition()\nself.receivers: Dict[UUID, weakref.ReferenceType[Receiver[T]]] = {}\nself.closed: bool = False\nself._latest: Optional[T] = None\nasync def close(self) -&gt; None:\n\"\"\"Close the Broadcast channel.\n        Any further attempts to [send()][frequenz.channels.Sender.send] data\n        will return `False`.\n        Receivers will still be able to drain the pending items on their queues,\n        but after that, subsequent\n        [receive()][frequenz.channels.Receiver.receive] calls will return `None`\n        immediately.\n        \"\"\"\nself._latest = None\nself.closed = True\nasync with self.recv_cv:\nself.recv_cv.notify_all()\ndef new_sender(self) -&gt; Sender[T]:\n\"\"\"Create a new broadcast sender.\n        Returns:\n            A Sender instance attached to the broadcast channel.\n        \"\"\"\nreturn Sender(self)\ndef new_receiver(\nself, name: Optional[str] = None, maxsize: int = 50\n) -&gt; Receiver[T]:\n\"\"\"Create a new broadcast receiver.\n        Broadcast receivers have their own buffer, and when messages are not\n        being consumed fast enough and the buffer fills up, old messages will\n        get dropped just in this receiver.\n        Args:\n            name: A name to identify the receiver in the logs.\n            maxsize: Size of the receiver's buffer.\n        Returns:\n            A Receiver instance attached to the broadcast channel.\n        \"\"\"\nuuid = uuid4()\nif name is None:\nname = str(uuid)\nrecv: Receiver[T] = Receiver(uuid, name, maxsize, self)\nself.receivers[uuid] = weakref.ref(recv)\nif self._resend_latest and self._latest is not None:\nrecv.enqueue(self._latest)\nreturn recv\ndef new_peekable(self) -&gt; Peekable[T]:\n\"\"\"Create a new Peekable for the broadcast channel.\n        A Peekable provides a [peek()][frequenz.channels.Peekable.peek] method\n        that allows the user to get a peek at the latest value in the channel,\n        without consuming anything.\n        Returns:\n            A Peekable to peek into the broadcast channel with.\n        \"\"\"\nreturn Peekable(self)\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Broadcast-functions","title":"Functions","text":""},{"location":"reference/frequenz/channels/#frequenz.channels.Broadcast.__init__","title":"<code>__init__(name, resend_latest=False)</code>","text":"<p>Create a Broadcast channel.</p> PARAMETER  DESCRIPTION <code>name</code> <p>A name for the broadcast channel, typically based on the type of data sent through it.  Used to identify the channel in the logs.</p> <p> TYPE: <code>str</code> </p> <code>resend_latest</code> <p>When True, every time a new receiver is created with <code>new_receiver</code>, it will automatically get sent the latest value on the channel.  This allows new receivers on slow streams to get the latest value as soon as they are created, without having to wait for the next message on the channel to arrive.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_broadcast.py</code> <pre><code>def __init__(self, name: str, resend_latest: bool = False) -&gt; None:\n\"\"\"Create a Broadcast channel.\n    Args:\n        name: A name for the broadcast channel, typically based on the type\n            of data sent through it.  Used to identify the channel in the\n            logs.\n        resend_latest: When True, every time a new receiver is created with\n            `new_receiver`, it will automatically get sent the latest value\n            on the channel.  This allows new receivers on slow streams to\n            get the latest value as soon as they are created, without having\n            to wait for the next message on the channel to arrive.\n    \"\"\"\nself.name: str = name\nself._resend_latest = resend_latest\nself.recv_cv: Condition = Condition()\nself.receivers: Dict[UUID, weakref.ReferenceType[Receiver[T]]] = {}\nself.closed: bool = False\nself._latest: Optional[T] = None\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Broadcast.close","title":"<code>close()</code>  <code>async</code>","text":"<p>Close the Broadcast channel.</p> <p>Any further attempts to send() data will return <code>False</code>.</p> <p>Receivers will still be able to drain the pending items on their queues, but after that, subsequent receive() calls will return <code>None</code> immediately.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_broadcast.py</code> <pre><code>async def close(self) -&gt; None:\n\"\"\"Close the Broadcast channel.\n    Any further attempts to [send()][frequenz.channels.Sender.send] data\n    will return `False`.\n    Receivers will still be able to drain the pending items on their queues,\n    but after that, subsequent\n    [receive()][frequenz.channels.Receiver.receive] calls will return `None`\n    immediately.\n    \"\"\"\nself._latest = None\nself.closed = True\nasync with self.recv_cv:\nself.recv_cv.notify_all()\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Broadcast.new_peekable","title":"<code>new_peekable()</code>","text":"<p>Create a new Peekable for the broadcast channel.</p> <p>A Peekable provides a peek() method that allows the user to get a peek at the latest value in the channel, without consuming anything.</p> RETURNS DESCRIPTION <code>Peekable[T]</code> <p>A Peekable to peek into the broadcast channel with.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_broadcast.py</code> <pre><code>def new_peekable(self) -&gt; Peekable[T]:\n\"\"\"Create a new Peekable for the broadcast channel.\n    A Peekable provides a [peek()][frequenz.channels.Peekable.peek] method\n    that allows the user to get a peek at the latest value in the channel,\n    without consuming anything.\n    Returns:\n        A Peekable to peek into the broadcast channel with.\n    \"\"\"\nreturn Peekable(self)\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Broadcast.new_receiver","title":"<code>new_receiver(name=None, maxsize=50)</code>","text":"<p>Create a new broadcast receiver.</p> <p>Broadcast receivers have their own buffer, and when messages are not being consumed fast enough and the buffer fills up, old messages will get dropped just in this receiver.</p> PARAMETER  DESCRIPTION <code>name</code> <p>A name to identify the receiver in the logs.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>maxsize</code> <p>Size of the receiver's buffer.</p> <p> TYPE: <code>int</code> DEFAULT: <code>50</code> </p> RETURNS DESCRIPTION <code>Receiver[T]</code> <p>A Receiver instance attached to the broadcast channel.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_broadcast.py</code> <pre><code>def new_receiver(\nself, name: Optional[str] = None, maxsize: int = 50\n) -&gt; Receiver[T]:\n\"\"\"Create a new broadcast receiver.\n    Broadcast receivers have their own buffer, and when messages are not\n    being consumed fast enough and the buffer fills up, old messages will\n    get dropped just in this receiver.\n    Args:\n        name: A name to identify the receiver in the logs.\n        maxsize: Size of the receiver's buffer.\n    Returns:\n        A Receiver instance attached to the broadcast channel.\n    \"\"\"\nuuid = uuid4()\nif name is None:\nname = str(uuid)\nrecv: Receiver[T] = Receiver(uuid, name, maxsize, self)\nself.receivers[uuid] = weakref.ref(recv)\nif self._resend_latest and self._latest is not None:\nrecv.enqueue(self._latest)\nreturn recv\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Broadcast.new_sender","title":"<code>new_sender()</code>","text":"<p>Create a new broadcast sender.</p> RETURNS DESCRIPTION <code>Sender[T]</code> <p>A Sender instance attached to the broadcast channel.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_broadcast.py</code> <pre><code>def new_sender(self) -&gt; Sender[T]:\n\"\"\"Create a new broadcast sender.\n    Returns:\n        A Sender instance attached to the broadcast channel.\n    \"\"\"\nreturn Sender(self)\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.ChannelClosedError","title":"<code>frequenz.channels.ChannelClosedError</code>","text":"<p>             Bases: <code>ChannelError</code></p> <p>Error raised when trying to operate on a closed channel.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_exceptions.py</code> <pre><code>class ChannelClosedError(ChannelError):\n\"\"\"Error raised when trying to operate on a closed channel.\"\"\"\ndef __init__(self, channel: Any):\n\"\"\"Create a `ChannelClosedError` instance.\n        Args:\n            channel: A reference to the channel that was closed.\n        \"\"\"\nsuper().__init__(f\"Channel {channel} was closed\", channel)\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.ChannelClosedError-functions","title":"Functions","text":""},{"location":"reference/frequenz/channels/#frequenz.channels.ChannelClosedError.__init__","title":"<code>__init__(channel)</code>","text":"<p>Create a <code>ChannelClosedError</code> instance.</p> PARAMETER  DESCRIPTION <code>channel</code> <p>A reference to the channel that was closed.</p> <p> TYPE: <code>Any</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_exceptions.py</code> <pre><code>def __init__(self, channel: Any):\n\"\"\"Create a `ChannelClosedError` instance.\n    Args:\n        channel: A reference to the channel that was closed.\n    \"\"\"\nsuper().__init__(f\"Channel {channel} was closed\", channel)\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.ChannelError","title":"<code>frequenz.channels.ChannelError</code>","text":"<p>             Bases: <code>Error</code></p> <p>An error produced in a channel.</p> <p>All exceptions generated by channels inherit from this exception.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_exceptions.py</code> <pre><code>class ChannelError(Error):\n\"\"\"An error produced in a channel.\n    All exceptions generated by channels inherit from this exception.\n    \"\"\"\ndef __init__(self, message: Any, channel: Any):\n\"\"\"Create a ChannelError instance.\n        Args:\n            message: An error message.\n            channel: A reference to the channel that encountered the error.\n        \"\"\"\nsuper().__init__(message)\nself.channel: Any = channel\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.ChannelError-functions","title":"Functions","text":""},{"location":"reference/frequenz/channels/#frequenz.channels.ChannelError.__init__","title":"<code>__init__(message, channel)</code>","text":"<p>Create a ChannelError instance.</p> PARAMETER  DESCRIPTION <code>message</code> <p>An error message.</p> <p> TYPE: <code>Any</code> </p> <code>channel</code> <p>A reference to the channel that encountered the error.</p> <p> TYPE: <code>Any</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_exceptions.py</code> <pre><code>def __init__(self, message: Any, channel: Any):\n\"\"\"Create a ChannelError instance.\n    Args:\n        message: An error message.\n        channel: A reference to the channel that encountered the error.\n    \"\"\"\nsuper().__init__(message)\nself.channel: Any = channel\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Error","title":"<code>frequenz.channels.Error</code>","text":"<p>             Bases: <code>RuntimeError</code></p> <p>Base error.</p> <p>All exceptions generated by this library inherit from this exception.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_exceptions.py</code> <pre><code>class Error(RuntimeError):\n\"\"\"Base error.\n    All exceptions generated by this library inherit from this exception.\n    \"\"\"\ndef __init__(self, message: Any):\n\"\"\"Create a ChannelError instance.\n        Args:\n            message: An error message.\n        \"\"\"\nsuper().__init__(message)\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Error-functions","title":"Functions","text":""},{"location":"reference/frequenz/channels/#frequenz.channels.Error.__init__","title":"<code>__init__(message)</code>","text":"<p>Create a ChannelError instance.</p> PARAMETER  DESCRIPTION <code>message</code> <p>An error message.</p> <p> TYPE: <code>Any</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_exceptions.py</code> <pre><code>def __init__(self, message: Any):\n\"\"\"Create a ChannelError instance.\n    Args:\n        message: An error message.\n    \"\"\"\nsuper().__init__(message)\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Peekable","title":"<code>frequenz.channels.Peekable</code>","text":"<p>             Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>A channel peekable.</p> <p>A Peekable provides a peek() method that allows the user to get a peek at the latest value in the channel, without consuming anything.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_base_classes.py</code> <pre><code>class Peekable(ABC, Generic[T]):\n\"\"\"A channel peekable.\n    A Peekable provides a [peek()][frequenz.channels.Peekable] method that\n    allows the user to get a peek at the latest value in the channel, without\n    consuming anything.\n    \"\"\"\n@abstractmethod\ndef peek(self) -&gt; Optional[T]:\n\"\"\"Return the latest value that was sent to the channel.\n        Returns:\n            The latest value received by the channel, and `None`, if nothing\n                has been sent to the channel yet.\n        \"\"\"\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Peekable-functions","title":"Functions","text":""},{"location":"reference/frequenz/channels/#frequenz.channels.Peekable.peek","title":"<code>peek()</code>  <code>abstractmethod</code>","text":"<p>Return the latest value that was sent to the channel.</p> RETURNS DESCRIPTION <code>Optional[T]</code> <p>The latest value received by the channel, and <code>None</code>, if nothing has been sent to the channel yet.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_base_classes.py</code> <pre><code>@abstractmethod\ndef peek(self) -&gt; Optional[T]:\n\"\"\"Return the latest value that was sent to the channel.\n    Returns:\n        The latest value received by the channel, and `None`, if nothing\n            has been sent to the channel yet.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Receiver","title":"<code>frequenz.channels.Receiver</code>","text":"<p>             Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>A channel Receiver.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_base_classes.py</code> <pre><code>class Receiver(ABC, Generic[T]):\n\"\"\"A channel Receiver.\"\"\"\nasync def __anext__(self) -&gt; T:\n\"\"\"Await the next value in the async iteration over received values.\n        Returns:\n            The next value received.\n        Raises:\n            StopAsyncIteration: if the receiver stopped producing messages.\n            ReceiverError: if there is some problem with the receiver.\n        \"\"\"\ntry:\nawait self.ready()\nreturn self.consume()\nexcept ReceiverStoppedError as exc:\nraise StopAsyncIteration() from exc\n@abstractmethod\nasync def ready(self) -&gt; bool:\n\"\"\"Wait until the receiver is ready with a value or an error.\n        Once a call to `ready()` has finished, the value should be read with\n        a call to `consume()` (`receive()` or iterated over). The receiver will\n        remain ready (this method will return immediately) until it is\n        consumed.\n        Returns:\n            Whether the receiver is still active.\n        \"\"\"\n@abstractmethod\ndef consume(self) -&gt; T:\n\"\"\"Return the latest value once `ready()` is complete.\n        `ready()` must be called before each call to `consume()`.\n        Returns:\n            The next value received.\n        Raises:\n            ReceiverStoppedError: if the receiver stopped producing messages.\n            ReceiverError: if there is some problem with the receiver.\n        \"\"\"\ndef __aiter__(self) -&gt; Receiver[T]:\n\"\"\"Initialize the async iterator over received values.\n        Returns:\n            `self`, since no extra setup is needed for the iterator.\n        \"\"\"\nreturn self\nasync def receive(self) -&gt; T:\n\"\"\"Receive a message from the channel.\n        Returns:\n            The received message.\n        Raises:\n            ReceiverStoppedError: if there is some problem with the receiver.\n            ReceiverError: if there is some problem with the receiver.\n        # noqa: DAR401 __cause__ (https://github.com/terrencepreilly/darglint/issues/181)\n        \"\"\"\ntry:\nreceived = await self.__anext__()  # pylint: disable=unnecessary-dunder-call\nexcept StopAsyncIteration as exc:\n# If we already had a cause and it was the receiver was stopped,\n# then reuse that error, as StopAsyncIteration is just an artifact\n# introduced by __anext__.\nif (\nisinstance(exc.__cause__, ReceiverStoppedError)\n# pylint is not smart enough to figure out we checked above\n# this is a ReceiverStoppedError and thus it does have\n# a receiver member\nand exc.__cause__.receiver is self  # pylint: disable=no-member\n):\nraise exc.__cause__\nraise ReceiverStoppedError(self) from exc\nreturn received\ndef map(self, call: Callable[[T], U]) -&gt; Receiver[U]:\n\"\"\"Return a receiver with `call` applied on incoming messages.\n        Args:\n            call: function to apply on incoming messages.\n        Returns:\n            A `Receiver` to read results of the given function from.\n        \"\"\"\nreturn _Map(self, call)\ndef into_peekable(self) -&gt; Peekable[T]:\n\"\"\"Convert the `Receiver` implementation into a `Peekable`.\n        Once this function has been called, the receiver will no longer be\n        usable, and calling `receive` on the receiver will raise an exception.\n        Raises:\n            NotImplementedError: when a `Receiver` implementation doesn't have\n                a custom `into_peekable` implementation.\n        \"\"\"\nraise NotImplementedError(\"This receiver does not implement `into_peekable`\")\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Receiver-functions","title":"Functions","text":""},{"location":"reference/frequenz/channels/#frequenz.channels.Receiver.__aiter__","title":"<code>__aiter__()</code>","text":"<p>Initialize the async iterator over received values.</p> RETURNS DESCRIPTION <code>Receiver[T]</code> <p><code>self</code>, since no extra setup is needed for the iterator.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_base_classes.py</code> <pre><code>def __aiter__(self) -&gt; Receiver[T]:\n\"\"\"Initialize the async iterator over received values.\n    Returns:\n        `self`, since no extra setup is needed for the iterator.\n    \"\"\"\nreturn self\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Receiver.__anext__","title":"<code>__anext__()</code>  <code>async</code>","text":"<p>Await the next value in the async iteration over received values.</p> RETURNS DESCRIPTION <code>T</code> <p>The next value received.</p> RAISES DESCRIPTION <code>StopAsyncIteration</code> <p>if the receiver stopped producing messages.</p> <code>ReceiverError</code> <p>if there is some problem with the receiver.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_base_classes.py</code> <pre><code>async def __anext__(self) -&gt; T:\n\"\"\"Await the next value in the async iteration over received values.\n    Returns:\n        The next value received.\n    Raises:\n        StopAsyncIteration: if the receiver stopped producing messages.\n        ReceiverError: if there is some problem with the receiver.\n    \"\"\"\ntry:\nawait self.ready()\nreturn self.consume()\nexcept ReceiverStoppedError as exc:\nraise StopAsyncIteration() from exc\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Receiver.consume","title":"<code>consume()</code>  <code>abstractmethod</code>","text":"<p>Return the latest value once <code>ready()</code> is complete.</p> <p><code>ready()</code> must be called before each call to <code>consume()</code>.</p> RETURNS DESCRIPTION <code>T</code> <p>The next value received.</p> RAISES DESCRIPTION <code>ReceiverStoppedError</code> <p>if the receiver stopped producing messages.</p> <code>ReceiverError</code> <p>if there is some problem with the receiver.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_base_classes.py</code> <pre><code>@abstractmethod\ndef consume(self) -&gt; T:\n\"\"\"Return the latest value once `ready()` is complete.\n    `ready()` must be called before each call to `consume()`.\n    Returns:\n        The next value received.\n    Raises:\n        ReceiverStoppedError: if the receiver stopped producing messages.\n        ReceiverError: if there is some problem with the receiver.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Receiver.into_peekable","title":"<code>into_peekable()</code>","text":"<p>Convert the <code>Receiver</code> implementation into a <code>Peekable</code>.</p> <p>Once this function has been called, the receiver will no longer be usable, and calling <code>receive</code> on the receiver will raise an exception.</p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>when a <code>Receiver</code> implementation doesn't have a custom <code>into_peekable</code> implementation.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_base_classes.py</code> <pre><code>def into_peekable(self) -&gt; Peekable[T]:\n\"\"\"Convert the `Receiver` implementation into a `Peekable`.\n    Once this function has been called, the receiver will no longer be\n    usable, and calling `receive` on the receiver will raise an exception.\n    Raises:\n        NotImplementedError: when a `Receiver` implementation doesn't have\n            a custom `into_peekable` implementation.\n    \"\"\"\nraise NotImplementedError(\"This receiver does not implement `into_peekable`\")\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Receiver.map","title":"<code>map(call)</code>","text":"<p>Return a receiver with <code>call</code> applied on incoming messages.</p> PARAMETER  DESCRIPTION <code>call</code> <p>function to apply on incoming messages.</p> <p> TYPE: <code>Callable[[T], U]</code> </p> RETURNS DESCRIPTION <code>Receiver[U]</code> <p>A <code>Receiver</code> to read results of the given function from.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_base_classes.py</code> <pre><code>def map(self, call: Callable[[T], U]) -&gt; Receiver[U]:\n\"\"\"Return a receiver with `call` applied on incoming messages.\n    Args:\n        call: function to apply on incoming messages.\n    Returns:\n        A `Receiver` to read results of the given function from.\n    \"\"\"\nreturn _Map(self, call)\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Receiver.ready","title":"<code>ready()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Wait until the receiver is ready with a value or an error.</p> <p>Once a call to <code>ready()</code> has finished, the value should be read with a call to <code>consume()</code> (<code>receive()</code> or iterated over). The receiver will remain ready (this method will return immediately) until it is consumed.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the receiver is still active.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_base_classes.py</code> <pre><code>@abstractmethod\nasync def ready(self) -&gt; bool:\n\"\"\"Wait until the receiver is ready with a value or an error.\n    Once a call to `ready()` has finished, the value should be read with\n    a call to `consume()` (`receive()` or iterated over). The receiver will\n    remain ready (this method will return immediately) until it is\n    consumed.\n    Returns:\n        Whether the receiver is still active.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Receiver.receive","title":"<code>receive()</code>  <code>async</code>","text":"<p>Receive a message from the channel.</p> RETURNS DESCRIPTION <code>T</code> <p>The received message.</p> RAISES DESCRIPTION <code>ReceiverStoppedError</code> <p>if there is some problem with the receiver.</p> <code>ReceiverError</code> <p>if there is some problem with the receiver.</p>"},{"location":"reference/frequenz/channels/#frequenz.channels.Receiver.receive--noqa-dar401-cause-httpsgithubcomterrencepreillydarglintissues181","title":"noqa: DAR401 cause (https://github.com/terrencepreilly/darglint/issues/181)","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_base_classes.py</code> <pre><code>async def receive(self) -&gt; T:\n\"\"\"Receive a message from the channel.\n    Returns:\n        The received message.\n    Raises:\n        ReceiverStoppedError: if there is some problem with the receiver.\n        ReceiverError: if there is some problem with the receiver.\n    # noqa: DAR401 __cause__ (https://github.com/terrencepreilly/darglint/issues/181)\n    \"\"\"\ntry:\nreceived = await self.__anext__()  # pylint: disable=unnecessary-dunder-call\nexcept StopAsyncIteration as exc:\n# If we already had a cause and it was the receiver was stopped,\n# then reuse that error, as StopAsyncIteration is just an artifact\n# introduced by __anext__.\nif (\nisinstance(exc.__cause__, ReceiverStoppedError)\n# pylint is not smart enough to figure out we checked above\n# this is a ReceiverStoppedError and thus it does have\n# a receiver member\nand exc.__cause__.receiver is self  # pylint: disable=no-member\n):\nraise exc.__cause__\nraise ReceiverStoppedError(self) from exc\nreturn received\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.ReceiverError","title":"<code>frequenz.channels.ReceiverError</code>","text":"<p>             Bases: <code>Error</code>, <code>Generic[T]</code></p> <p>An error produced in a Receiver.</p> <p>All exceptions generated by receivers inherit from this exception.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_exceptions.py</code> <pre><code>class ReceiverError(Error, Generic[T]):\n\"\"\"An error produced in a [Receiver][frequenz.channels.Receiver].\n    All exceptions generated by receivers inherit from this exception.\n    \"\"\"\ndef __init__(self, message: Any, receiver: _base_classes.Receiver[T]):\n\"\"\"Create an instance.\n        Args:\n            message: An error message.\n            receiver: The [Receiver][frequenz.channels.Receiver] where the\n                error happened.\n        \"\"\"\nsuper().__init__(message)\nself.receiver: _base_classes.Receiver[T] = receiver\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.ReceiverError-functions","title":"Functions","text":""},{"location":"reference/frequenz/channels/#frequenz.channels.ReceiverError.__init__","title":"<code>__init__(message, receiver)</code>","text":"<p>Create an instance.</p> PARAMETER  DESCRIPTION <code>message</code> <p>An error message.</p> <p> TYPE: <code>Any</code> </p> <code>receiver</code> <p>The Receiver where the error happened.</p> <p> TYPE: <code>_base_classes.Receiver[T]</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_exceptions.py</code> <pre><code>def __init__(self, message: Any, receiver: _base_classes.Receiver[T]):\n\"\"\"Create an instance.\n    Args:\n        message: An error message.\n        receiver: The [Receiver][frequenz.channels.Receiver] where the\n            error happened.\n    \"\"\"\nsuper().__init__(message)\nself.receiver: _base_classes.Receiver[T] = receiver\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.ReceiverInvalidatedError","title":"<code>frequenz.channels.ReceiverInvalidatedError</code>","text":"<p>             Bases: <code>ReceiverError[T]</code></p> <p>The Receiver was invalidated.</p> <p>This happens when the Receiver is converted into a Peekable.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_exceptions.py</code> <pre><code>class ReceiverInvalidatedError(ReceiverError[T]):\n\"\"\"The [Receiver][frequenz.channels.Receiver] was invalidated.\n    This happens when the Receiver is converted\n    [into][frequenz.channels.Receiver.into_peekable]\n    a [Peekable][frequenz.channels.Peekable].\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.ReceiverStoppedError","title":"<code>frequenz.channels.ReceiverStoppedError</code>","text":"<p>             Bases: <code>ReceiverError[T]</code></p> <p>The Receiver stopped producing messages.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_exceptions.py</code> <pre><code>class ReceiverStoppedError(ReceiverError[T]):\n\"\"\"The [Receiver][frequenz.channels.Receiver] stopped producing messages.\"\"\"\ndef __init__(self, receiver: _base_classes.Receiver[T]):\n\"\"\"Create an instance.\n        Args:\n            receiver: The [Receiver][frequenz.channels.Receiver] where the\n                error happened.\n        \"\"\"\nsuper().__init__(f\"Receiver {receiver} was stopped\", receiver)\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.ReceiverStoppedError-functions","title":"Functions","text":""},{"location":"reference/frequenz/channels/#frequenz.channels.ReceiverStoppedError.__init__","title":"<code>__init__(receiver)</code>","text":"<p>Create an instance.</p> PARAMETER  DESCRIPTION <code>receiver</code> <p>The Receiver where the error happened.</p> <p> TYPE: <code>_base_classes.Receiver[T]</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_exceptions.py</code> <pre><code>def __init__(self, receiver: _base_classes.Receiver[T]):\n\"\"\"Create an instance.\n    Args:\n        receiver: The [Receiver][frequenz.channels.Receiver] where the\n            error happened.\n    \"\"\"\nsuper().__init__(f\"Receiver {receiver} was stopped\", receiver)\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Sender","title":"<code>frequenz.channels.Sender</code>","text":"<p>             Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>A channel Sender.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_base_classes.py</code> <pre><code>class Sender(ABC, Generic[T]):\n\"\"\"A channel Sender.\"\"\"\n@abstractmethod\nasync def send(self, msg: T) -&gt; None:\n\"\"\"Send a message to the channel.\n        Args:\n            msg: The message to be sent.\n        Raises:\n            SenderError: if there was an error sending the message.\n        \"\"\"\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Sender-functions","title":"Functions","text":""},{"location":"reference/frequenz/channels/#frequenz.channels.Sender.send","title":"<code>send(msg)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Send a message to the channel.</p> PARAMETER  DESCRIPTION <code>msg</code> <p>The message to be sent.</p> <p> TYPE: <code>T</code> </p> RAISES DESCRIPTION <code>SenderError</code> <p>if there was an error sending the message.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_base_classes.py</code> <pre><code>@abstractmethod\nasync def send(self, msg: T) -&gt; None:\n\"\"\"Send a message to the channel.\n    Args:\n        msg: The message to be sent.\n    Raises:\n        SenderError: if there was an error sending the message.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.SenderError","title":"<code>frequenz.channels.SenderError</code>","text":"<p>             Bases: <code>Error</code>, <code>Generic[T]</code></p> <p>An error produced in a Sender.</p> <p>All exceptions generated by senders inherit from this exception.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_exceptions.py</code> <pre><code>class SenderError(Error, Generic[T]):\n\"\"\"An error produced in a [Sender][frequenz.channels.Sender].\n    All exceptions generated by senders inherit from this exception.\n    \"\"\"\ndef __init__(self, message: Any, sender: _base_classes.Sender[T]):\n\"\"\"Create an instance.\n        Args:\n            message: An error message.\n            sender: The [Sender][frequenz.channels.Sender] where the error\n                happened.\n        \"\"\"\nsuper().__init__(message)\nself.sender: _base_classes.Sender[T] = sender\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.SenderError-functions","title":"Functions","text":""},{"location":"reference/frequenz/channels/#frequenz.channels.SenderError.__init__","title":"<code>__init__(message, sender)</code>","text":"<p>Create an instance.</p> PARAMETER  DESCRIPTION <code>message</code> <p>An error message.</p> <p> TYPE: <code>Any</code> </p> <code>sender</code> <p>The Sender where the error happened.</p> <p> TYPE: <code>_base_classes.Sender[T]</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_exceptions.py</code> <pre><code>def __init__(self, message: Any, sender: _base_classes.Sender[T]):\n\"\"\"Create an instance.\n    Args:\n        message: An error message.\n        sender: The [Sender][frequenz.channels.Sender] where the error\n            happened.\n    \"\"\"\nsuper().__init__(message)\nself.sender: _base_classes.Sender[T] = sender\n</code></pre>"},{"location":"reference/frequenz/channels/util/","title":"util","text":""},{"location":"reference/frequenz/channels/util/#frequenz.channels.util","title":"<code>frequenz.channels.util</code>","text":"<p>Channel utilities.</p> <p>A module with several utilities to work with channels:</p> <ul> <li> <p>Event:   A receiver that can be made ready through an event.</p> </li> <li> <p>FileWatcher:   A receiver that watches for file events.</p> </li> <li> <p>Merge:   A receiver that merge messages coming from   multiple receivers into a single stream.</p> </li> <li> <p>MergeNamed:   A receiver that merge messages coming from   multiple receivers into a single named stream, allowing to identify the   origin of each message.</p> </li> <li> <p>Timer:   A receiver that ticks at certain intervals.</p> </li> <li> <p>select:  Iterate over the values of all   receivers as new values become available.</p> </li> </ul>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util-classes","title":"Classes","text":""},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.Event","title":"<code>frequenz.channels.util.Event</code>","text":"<p>             Bases: <code>_base_classes.Receiver[None]</code></p> <p>A receiver that can be made ready through an event.</p> <p>The receiver (the <code>ready()</code> method) will wait until <code>set()</code> is called.  At that point the receiver will wait again after the event is <code>consume()</code>d.</p> <p>The receiver can be completely stopped by calling <code>stop()</code>.</p> Example <pre><code>import asyncio\nfrom frequenz.channels import Receiver\nfrom frequenz.channels.util import Event, select, selected_from\nother_receiver: Receiver[int] = ...\nexit_event = Event()\nasync def exit_after_10_seconds() -&gt; None:\nasyncio.sleep(10)\nexit_event.set()\nasyncio.ensure_future(exit_after_10_seconds())\nasync for selected in select(exit_event, other_receiver):\nif selected_from(selected, exit_event):\nbreak\nif selected_from(selected, other_receiver):\nprint(selected.value)\nelse:\nassert False, \"Unknow receiver selected\"\n</code></pre> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/util/_event.py</code> <pre><code>class Event(_base_classes.Receiver[None]):\n\"\"\"A receiver that can be made ready through an event.\n    The receiver (the [`ready()`][frequenz.channels.util.Event.ready] method) will wait\n    until [`set()`][frequenz.channels.util.Event.set] is called.  At that point the\n    receiver will wait again after the event is\n    [`consume()`][frequenz.channels.Receiver.consume]d.\n    The receiver can be completely stopped by calling\n    [`stop()`][frequenz.channels.util.Event.stop].\n    Example:\n        ```python\n        import asyncio\n        from frequenz.channels import Receiver\n        from frequenz.channels.util import Event, select, selected_from\n        other_receiver: Receiver[int] = ...\n        exit_event = Event()\n        async def exit_after_10_seconds() -&gt; None:\n            asyncio.sleep(10)\n            exit_event.set()\n        asyncio.ensure_future(exit_after_10_seconds())\n        async for selected in select(exit_event, other_receiver):\n            if selected_from(selected, exit_event):\n                break\n            if selected_from(selected, other_receiver):\n                print(selected.value)\n            else:\n                assert False, \"Unknow receiver selected\"\n        ```\n    \"\"\"\ndef __init__(self, name: str | None = None) -&gt; None:\n\"\"\"Create a new instance.\n        Args:\n            name: The name of the receiver.  If `None` the `id(self)` will be used as\n                the name.  This is only for debugging purposes, it will be shown in the\n                string representation of the receiver.\n        \"\"\"\nself._event: _asyncio.Event = _asyncio.Event()\n\"\"\"The event that is set when the receiver is ready.\"\"\"\nself._name: str = name or str(id(self))\n\"\"\"The name of the receiver.\n        This is for debugging purposes, it will be shown in the string representation\n        of the receiver.\n        \"\"\"\nself._is_set: bool = False\n\"\"\"Whether the receiver is ready to be consumed.\n        This is used to differentiate between when the receiver was stopped (the event\n        is triggered too) but still there is an event to be consumed and when it was\n        stopped but was not explicitly set().\n        \"\"\"\nself._is_stopped: bool = False\n\"\"\"Whether the receiver is stopped.\"\"\"\n@property\ndef name(self) -&gt; str:\n\"\"\"The name of this receiver.\n        This is for debugging purposes, it will be shown in the string representation\n        of this receiver.\n        Returns:\n            The name of this receiver.\n        \"\"\"\nreturn self._name\n@property\ndef is_set(self) -&gt; bool:\n\"\"\"Whether this receiver is set (ready).\n        Returns:\n            Whether this receiver is set (ready).\n        \"\"\"\nreturn self._is_set\n@property\ndef is_stopped(self) -&gt; bool:\n\"\"\"Whether this receiver is stopped.\n        Returns:\n            Whether this receiver is stopped.\n        \"\"\"\nreturn self._is_stopped\ndef stop(self) -&gt; None:\n\"\"\"Stop this receiver.\"\"\"\nself._is_stopped = True\nself._event.set()\ndef set(self) -&gt; None:\n\"\"\"Trigger the event (make the receiver ready).\"\"\"\nself._is_set = True\nself._event.set()\nasync def ready(self) -&gt; bool:\n\"\"\"Wait until this receiver is ready.\n        Returns:\n            Whether this receiver is still running.\n        \"\"\"\nif self._is_stopped:\nreturn False\nawait self._event.wait()\nreturn not self._is_stopped\ndef consume(self) -&gt; None:\n\"\"\"Consume the event.\n        This makes this receiver wait again until the event is set again.\n        Raises:\n            ReceiverStoppedError: If this receiver is stopped.\n        \"\"\"\nif not self._is_set and self._is_stopped:\nraise _exceptions.ReceiverStoppedError(self)\nassert self._is_set, \"calls to `consume()` must be follow a call to `ready()`\"\nself._is_set = False\nself._event.clear()\ndef __str__(self) -&gt; str:\n\"\"\"Return a string representation of this receiver.\n        Returns:\n            A string representation of this receiver.\n        \"\"\"\nreturn f\"{type(self).__name__}({self._name!r})\"\ndef __repr__(self) -&gt; str:\n\"\"\"Return a string representation of this receiver.\n        Returns:\n            A string representation of this receiver.\n        \"\"\"\nreturn (\nf\"&lt;{type(self).__name__} name={self._name!r} is_set={self.is_set!r} \"\nf\"is_stopped={self.is_stopped!r}&gt;\"\n)\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.Event-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.Event.is_set","title":"<code>is_set: bool</code>  <code>property</code>","text":"<p>Whether this receiver is set (ready).</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this receiver is set (ready).</p>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.Event.is_stopped","title":"<code>is_stopped: bool</code>  <code>property</code>","text":"<p>Whether this receiver is stopped.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this receiver is stopped.</p>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.Event.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>The name of this receiver.</p> <p>This is for debugging purposes, it will be shown in the string representation of this receiver.</p> RETURNS DESCRIPTION <code>str</code> <p>The name of this receiver.</p>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.Event-functions","title":"Functions","text":""},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.Event.__aiter__","title":"<code>__aiter__()</code>","text":"<p>Initialize the async iterator over received values.</p> RETURNS DESCRIPTION <code>Receiver[T]</code> <p><code>self</code>, since no extra setup is needed for the iterator.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_base_classes.py</code> <pre><code>def __aiter__(self) -&gt; Receiver[T]:\n\"\"\"Initialize the async iterator over received values.\n    Returns:\n        `self`, since no extra setup is needed for the iterator.\n    \"\"\"\nreturn self\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.Event.__anext__","title":"<code>__anext__()</code>  <code>async</code>","text":"<p>Await the next value in the async iteration over received values.</p> RETURNS DESCRIPTION <code>T</code> <p>The next value received.</p> RAISES DESCRIPTION <code>StopAsyncIteration</code> <p>if the receiver stopped producing messages.</p> <code>ReceiverError</code> <p>if there is some problem with the receiver.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_base_classes.py</code> <pre><code>async def __anext__(self) -&gt; T:\n\"\"\"Await the next value in the async iteration over received values.\n    Returns:\n        The next value received.\n    Raises:\n        StopAsyncIteration: if the receiver stopped producing messages.\n        ReceiverError: if there is some problem with the receiver.\n    \"\"\"\ntry:\nawait self.ready()\nreturn self.consume()\nexcept ReceiverStoppedError as exc:\nraise StopAsyncIteration() from exc\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.Event.__init__","title":"<code>__init__(name=None)</code>","text":"<p>Create a new instance.</p> PARAMETER  DESCRIPTION <code>name</code> <p>The name of the receiver.  If <code>None</code> the <code>id(self)</code> will be used as the name.  This is only for debugging purposes, it will be shown in the string representation of the receiver.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/util/_event.py</code> <pre><code>def __init__(self, name: str | None = None) -&gt; None:\n\"\"\"Create a new instance.\n    Args:\n        name: The name of the receiver.  If `None` the `id(self)` will be used as\n            the name.  This is only for debugging purposes, it will be shown in the\n            string representation of the receiver.\n    \"\"\"\nself._event: _asyncio.Event = _asyncio.Event()\n\"\"\"The event that is set when the receiver is ready.\"\"\"\nself._name: str = name or str(id(self))\n\"\"\"The name of the receiver.\n    This is for debugging purposes, it will be shown in the string representation\n    of the receiver.\n    \"\"\"\nself._is_set: bool = False\n\"\"\"Whether the receiver is ready to be consumed.\n    This is used to differentiate between when the receiver was stopped (the event\n    is triggered too) but still there is an event to be consumed and when it was\n    stopped but was not explicitly set().\n    \"\"\"\nself._is_stopped: bool = False\n\"\"\"Whether the receiver is stopped.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.Event.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a string representation of this receiver.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this receiver.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/util/_event.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Return a string representation of this receiver.\n    Returns:\n        A string representation of this receiver.\n    \"\"\"\nreturn (\nf\"&lt;{type(self).__name__} name={self._name!r} is_set={self.is_set!r} \"\nf\"is_stopped={self.is_stopped!r}&gt;\"\n)\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.Event.__str__","title":"<code>__str__()</code>","text":"<p>Return a string representation of this receiver.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this receiver.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/util/_event.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Return a string representation of this receiver.\n    Returns:\n        A string representation of this receiver.\n    \"\"\"\nreturn f\"{type(self).__name__}({self._name!r})\"\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.Event.consume","title":"<code>consume()</code>","text":"<p>Consume the event.</p> <p>This makes this receiver wait again until the event is set again.</p> RAISES DESCRIPTION <code>ReceiverStoppedError</code> <p>If this receiver is stopped.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/util/_event.py</code> <pre><code>def consume(self) -&gt; None:\n\"\"\"Consume the event.\n    This makes this receiver wait again until the event is set again.\n    Raises:\n        ReceiverStoppedError: If this receiver is stopped.\n    \"\"\"\nif not self._is_set and self._is_stopped:\nraise _exceptions.ReceiverStoppedError(self)\nassert self._is_set, \"calls to `consume()` must be follow a call to `ready()`\"\nself._is_set = False\nself._event.clear()\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.Event.into_peekable","title":"<code>into_peekable()</code>","text":"<p>Convert the <code>Receiver</code> implementation into a <code>Peekable</code>.</p> <p>Once this function has been called, the receiver will no longer be usable, and calling <code>receive</code> on the receiver will raise an exception.</p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>when a <code>Receiver</code> implementation doesn't have a custom <code>into_peekable</code> implementation.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_base_classes.py</code> <pre><code>def into_peekable(self) -&gt; Peekable[T]:\n\"\"\"Convert the `Receiver` implementation into a `Peekable`.\n    Once this function has been called, the receiver will no longer be\n    usable, and calling `receive` on the receiver will raise an exception.\n    Raises:\n        NotImplementedError: when a `Receiver` implementation doesn't have\n            a custom `into_peekable` implementation.\n    \"\"\"\nraise NotImplementedError(\"This receiver does not implement `into_peekable`\")\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.Event.map","title":"<code>map(call)</code>","text":"<p>Return a receiver with <code>call</code> applied on incoming messages.</p> PARAMETER  DESCRIPTION <code>call</code> <p>function to apply on incoming messages.</p> <p> TYPE: <code>Callable[[T], U]</code> </p> RETURNS DESCRIPTION <code>Receiver[U]</code> <p>A <code>Receiver</code> to read results of the given function from.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_base_classes.py</code> <pre><code>def map(self, call: Callable[[T], U]) -&gt; Receiver[U]:\n\"\"\"Return a receiver with `call` applied on incoming messages.\n    Args:\n        call: function to apply on incoming messages.\n    Returns:\n        A `Receiver` to read results of the given function from.\n    \"\"\"\nreturn _Map(self, call)\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.Event.ready","title":"<code>ready()</code>  <code>async</code>","text":"<p>Wait until this receiver is ready.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this receiver is still running.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/util/_event.py</code> <pre><code>async def ready(self) -&gt; bool:\n\"\"\"Wait until this receiver is ready.\n    Returns:\n        Whether this receiver is still running.\n    \"\"\"\nif self._is_stopped:\nreturn False\nawait self._event.wait()\nreturn not self._is_stopped\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.Event.receive","title":"<code>receive()</code>  <code>async</code>","text":"<p>Receive a message from the channel.</p> RETURNS DESCRIPTION <code>T</code> <p>The received message.</p> RAISES DESCRIPTION <code>ReceiverStoppedError</code> <p>if there is some problem with the receiver.</p> <code>ReceiverError</code> <p>if there is some problem with the receiver.</p>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.Event.receive--noqa-dar401-cause-httpsgithubcomterrencepreillydarglintissues181","title":"noqa: DAR401 cause (https://github.com/terrencepreilly/darglint/issues/181)","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_base_classes.py</code> <pre><code>async def receive(self) -&gt; T:\n\"\"\"Receive a message from the channel.\n    Returns:\n        The received message.\n    Raises:\n        ReceiverStoppedError: if there is some problem with the receiver.\n        ReceiverError: if there is some problem with the receiver.\n    # noqa: DAR401 __cause__ (https://github.com/terrencepreilly/darglint/issues/181)\n    \"\"\"\ntry:\nreceived = await self.__anext__()  # pylint: disable=unnecessary-dunder-call\nexcept StopAsyncIteration as exc:\n# If we already had a cause and it was the receiver was stopped,\n# then reuse that error, as StopAsyncIteration is just an artifact\n# introduced by __anext__.\nif (\nisinstance(exc.__cause__, ReceiverStoppedError)\n# pylint is not smart enough to figure out we checked above\n# this is a ReceiverStoppedError and thus it does have\n# a receiver member\nand exc.__cause__.receiver is self  # pylint: disable=no-member\n):\nraise exc.__cause__\nraise ReceiverStoppedError(self) from exc\nreturn received\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.Event.set","title":"<code>set()</code>","text":"<p>Trigger the event (make the receiver ready).</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/util/_event.py</code> <pre><code>def set(self) -&gt; None:\n\"\"\"Trigger the event (make the receiver ready).\"\"\"\nself._is_set = True\nself._event.set()\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.Event.stop","title":"<code>stop()</code>","text":"<p>Stop this receiver.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/util/_event.py</code> <pre><code>def stop(self) -&gt; None:\n\"\"\"Stop this receiver.\"\"\"\nself._is_stopped = True\nself._event.set()\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.FileWatcher","title":"<code>frequenz.channels.util.FileWatcher</code>","text":"<p>             Bases: <code>Receiver['FileWatcher.Event']</code></p> <p>A channel receiver that watches for file events.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/util/_file_watcher.py</code> <pre><code>class FileWatcher(Receiver[\"FileWatcher.Event\"]):\n\"\"\"A channel receiver that watches for file events.\"\"\"\nclass EventType(Enum):\n\"\"\"Available types of changes to watch for.\"\"\"\nCREATE = Change.added\n\"\"\"A new file was created.\"\"\"\nMODIFY = Change.modified\n\"\"\"An existing file was modified.\"\"\"\nDELETE = Change.deleted\n\"\"\"An existing file was deleted.\"\"\"\n@dataclass(frozen=True)\nclass Event:\n\"\"\"A file change event.\"\"\"\ntype: FileWatcher.EventType\n\"\"\"The type of change that was observed.\"\"\"\npath: pathlib.Path\n\"\"\"The path where the change was observed.\"\"\"\ndef __init__(\nself,\npaths: list[pathlib.Path | str],\nevent_types: abc.Iterable[EventType] = frozenset(EventType),\n) -&gt; None:\n\"\"\"Create a `FileWatcher` instance.\n        Args:\n            paths: Paths to watch for changes.\n            event_types: Types of events to watch for. Defaults to watch for\n                all event types.\n        \"\"\"\nself.event_types: frozenset[FileWatcher.EventType] = frozenset(event_types)\nself._stop_event = asyncio.Event()\nself._paths = [\npath if isinstance(path, pathlib.Path) else pathlib.Path(path)\nfor path in paths\n]\nself._awatch = awatch(\n*self._paths, stop_event=self._stop_event, watch_filter=self._filter_events\n)\nself._awatch_stopped_exc: Exception | None = None\nself._changes: set[FileChange] = set()\ndef _filter_events(\nself,\nchange: Change,\npath: str,  # pylint: disable=unused-argument\n) -&gt; bool:\n\"\"\"Filter events based on the event type and path.\n        Args:\n            change: The type of change to be notified.\n            path: The path of the file that changed.\n        Returns:\n            Whether the event should be notified.\n        \"\"\"\nreturn change in [event_type.value for event_type in self.event_types]\ndef __del__(self) -&gt; None:\n\"\"\"Cleanup registered watches.\n        `awatch` passes the `stop_event` to a separate task/thread. This way\n        `awatch` getting destroyed properly. The background task will continue\n        until the signal is received.\n        \"\"\"\nself._stop_event.set()\nasync def ready(self) -&gt; bool:\n\"\"\"Wait until the receiver is ready with a value or an error.\n        Once a call to `ready()` has finished, the value should be read with\n        a call to `consume()` (`receive()` or iterated over). The receiver will\n        remain ready (this method will return immediately) until it is\n        consumed.\n        Returns:\n            Whether the receiver is still active.\n        \"\"\"\n# if there are messages waiting to be consumed, return immediately.\nif self._changes:\nreturn True\n# if it was already stopped, return immediately.\nif self._awatch_stopped_exc is not None:\nreturn False\ntry:\nself._changes = await self._awatch.__anext__()\nexcept StopAsyncIteration as err:\nself._awatch_stopped_exc = err\nreturn True\ndef consume(self) -&gt; Event:\n\"\"\"Return the latest event once `ready` is complete.\n        Returns:\n            The next event that was received.\n        Raises:\n            ReceiverStoppedError: if there is some problem with the receiver.\n        \"\"\"\nif not self._changes and self._awatch_stopped_exc is not None:\nraise ReceiverStoppedError(self) from self._awatch_stopped_exc\nassert self._changes, \"`consume()` must be preceeded by a call to `ready()`\"\n# Tuple of (Change, path) returned by watchfiles\nchange, path_str = self._changes.pop()\nreturn FileWatcher.Event(\ntype=FileWatcher.EventType(change), path=pathlib.Path(path_str)\n)\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.FileWatcher-classes","title":"Classes","text":""},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.FileWatcher.Event","title":"<code>Event</code>  <code>dataclass</code>","text":"<p>A file change event.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/util/_file_watcher.py</code> <pre><code>@dataclass(frozen=True)\nclass Event:\n\"\"\"A file change event.\"\"\"\ntype: FileWatcher.EventType\n\"\"\"The type of change that was observed.\"\"\"\npath: pathlib.Path\n\"\"\"The path where the change was observed.\"\"\"\n</code></pre> Attributes\u00a4 <code>path: pathlib.Path</code> <code>instance-attribute</code> \u00a4 <p>The path where the change was observed.</p> <code>type: FileWatcher.EventType</code> <code>instance-attribute</code> \u00a4 <p>The type of change that was observed.</p>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.FileWatcher.EventType","title":"<code>EventType</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Available types of changes to watch for.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/util/_file_watcher.py</code> <pre><code>class EventType(Enum):\n\"\"\"Available types of changes to watch for.\"\"\"\nCREATE = Change.added\n\"\"\"A new file was created.\"\"\"\nMODIFY = Change.modified\n\"\"\"An existing file was modified.\"\"\"\nDELETE = Change.deleted\n\"\"\"An existing file was deleted.\"\"\"\n</code></pre> Attributes\u00a4 <code>CREATE = Change.added</code> <code>class-attribute</code> <code>instance-attribute</code> \u00a4 <p>A new file was created.</p> <code>DELETE = Change.deleted</code> <code>class-attribute</code> <code>instance-attribute</code> \u00a4 <p>An existing file was deleted.</p> <code>MODIFY = Change.modified</code> <code>class-attribute</code> <code>instance-attribute</code> \u00a4 <p>An existing file was modified.</p>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.FileWatcher-functions","title":"Functions","text":""},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.FileWatcher.__aiter__","title":"<code>__aiter__()</code>","text":"<p>Initialize the async iterator over received values.</p> RETURNS DESCRIPTION <code>Receiver[T]</code> <p><code>self</code>, since no extra setup is needed for the iterator.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_base_classes.py</code> <pre><code>def __aiter__(self) -&gt; Receiver[T]:\n\"\"\"Initialize the async iterator over received values.\n    Returns:\n        `self`, since no extra setup is needed for the iterator.\n    \"\"\"\nreturn self\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.FileWatcher.__anext__","title":"<code>__anext__()</code>  <code>async</code>","text":"<p>Await the next value in the async iteration over received values.</p> RETURNS DESCRIPTION <code>T</code> <p>The next value received.</p> RAISES DESCRIPTION <code>StopAsyncIteration</code> <p>if the receiver stopped producing messages.</p> <code>ReceiverError</code> <p>if there is some problem with the receiver.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_base_classes.py</code> <pre><code>async def __anext__(self) -&gt; T:\n\"\"\"Await the next value in the async iteration over received values.\n    Returns:\n        The next value received.\n    Raises:\n        StopAsyncIteration: if the receiver stopped producing messages.\n        ReceiverError: if there is some problem with the receiver.\n    \"\"\"\ntry:\nawait self.ready()\nreturn self.consume()\nexcept ReceiverStoppedError as exc:\nraise StopAsyncIteration() from exc\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.FileWatcher.__del__","title":"<code>__del__()</code>","text":"<p>Cleanup registered watches.</p> <p><code>awatch</code> passes the <code>stop_event</code> to a separate task/thread. This way <code>awatch</code> getting destroyed properly. The background task will continue until the signal is received.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/util/_file_watcher.py</code> <pre><code>def __del__(self) -&gt; None:\n\"\"\"Cleanup registered watches.\n    `awatch` passes the `stop_event` to a separate task/thread. This way\n    `awatch` getting destroyed properly. The background task will continue\n    until the signal is received.\n    \"\"\"\nself._stop_event.set()\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.FileWatcher.__init__","title":"<code>__init__(paths, event_types=frozenset(EventType))</code>","text":"<p>Create a <code>FileWatcher</code> instance.</p> PARAMETER  DESCRIPTION <code>paths</code> <p>Paths to watch for changes.</p> <p> TYPE: <code>list[Path | str]</code> </p> <code>event_types</code> <p>Types of events to watch for. Defaults to watch for all event types.</p> <p> TYPE: <code>abc.Iterable[EventType]</code> DEFAULT: <code>frozenset(EventType)</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/util/_file_watcher.py</code> <pre><code>def __init__(\nself,\npaths: list[pathlib.Path | str],\nevent_types: abc.Iterable[EventType] = frozenset(EventType),\n) -&gt; None:\n\"\"\"Create a `FileWatcher` instance.\n    Args:\n        paths: Paths to watch for changes.\n        event_types: Types of events to watch for. Defaults to watch for\n            all event types.\n    \"\"\"\nself.event_types: frozenset[FileWatcher.EventType] = frozenset(event_types)\nself._stop_event = asyncio.Event()\nself._paths = [\npath if isinstance(path, pathlib.Path) else pathlib.Path(path)\nfor path in paths\n]\nself._awatch = awatch(\n*self._paths, stop_event=self._stop_event, watch_filter=self._filter_events\n)\nself._awatch_stopped_exc: Exception | None = None\nself._changes: set[FileChange] = set()\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.FileWatcher.consume","title":"<code>consume()</code>","text":"<p>Return the latest event once <code>ready</code> is complete.</p> RETURNS DESCRIPTION <code>Event</code> <p>The next event that was received.</p> RAISES DESCRIPTION <code>ReceiverStoppedError</code> <p>if there is some problem with the receiver.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/util/_file_watcher.py</code> <pre><code>def consume(self) -&gt; Event:\n\"\"\"Return the latest event once `ready` is complete.\n    Returns:\n        The next event that was received.\n    Raises:\n        ReceiverStoppedError: if there is some problem with the receiver.\n    \"\"\"\nif not self._changes and self._awatch_stopped_exc is not None:\nraise ReceiverStoppedError(self) from self._awatch_stopped_exc\nassert self._changes, \"`consume()` must be preceeded by a call to `ready()`\"\n# Tuple of (Change, path) returned by watchfiles\nchange, path_str = self._changes.pop()\nreturn FileWatcher.Event(\ntype=FileWatcher.EventType(change), path=pathlib.Path(path_str)\n)\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.FileWatcher.into_peekable","title":"<code>into_peekable()</code>","text":"<p>Convert the <code>Receiver</code> implementation into a <code>Peekable</code>.</p> <p>Once this function has been called, the receiver will no longer be usable, and calling <code>receive</code> on the receiver will raise an exception.</p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>when a <code>Receiver</code> implementation doesn't have a custom <code>into_peekable</code> implementation.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_base_classes.py</code> <pre><code>def into_peekable(self) -&gt; Peekable[T]:\n\"\"\"Convert the `Receiver` implementation into a `Peekable`.\n    Once this function has been called, the receiver will no longer be\n    usable, and calling `receive` on the receiver will raise an exception.\n    Raises:\n        NotImplementedError: when a `Receiver` implementation doesn't have\n            a custom `into_peekable` implementation.\n    \"\"\"\nraise NotImplementedError(\"This receiver does not implement `into_peekable`\")\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.FileWatcher.map","title":"<code>map(call)</code>","text":"<p>Return a receiver with <code>call</code> applied on incoming messages.</p> PARAMETER  DESCRIPTION <code>call</code> <p>function to apply on incoming messages.</p> <p> TYPE: <code>Callable[[T], U]</code> </p> RETURNS DESCRIPTION <code>Receiver[U]</code> <p>A <code>Receiver</code> to read results of the given function from.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_base_classes.py</code> <pre><code>def map(self, call: Callable[[T], U]) -&gt; Receiver[U]:\n\"\"\"Return a receiver with `call` applied on incoming messages.\n    Args:\n        call: function to apply on incoming messages.\n    Returns:\n        A `Receiver` to read results of the given function from.\n    \"\"\"\nreturn _Map(self, call)\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.FileWatcher.ready","title":"<code>ready()</code>  <code>async</code>","text":"<p>Wait until the receiver is ready with a value or an error.</p> <p>Once a call to <code>ready()</code> has finished, the value should be read with a call to <code>consume()</code> (<code>receive()</code> or iterated over). The receiver will remain ready (this method will return immediately) until it is consumed.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the receiver is still active.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/util/_file_watcher.py</code> <pre><code>async def ready(self) -&gt; bool:\n\"\"\"Wait until the receiver is ready with a value or an error.\n    Once a call to `ready()` has finished, the value should be read with\n    a call to `consume()` (`receive()` or iterated over). The receiver will\n    remain ready (this method will return immediately) until it is\n    consumed.\n    Returns:\n        Whether the receiver is still active.\n    \"\"\"\n# if there are messages waiting to be consumed, return immediately.\nif self._changes:\nreturn True\n# if it was already stopped, return immediately.\nif self._awatch_stopped_exc is not None:\nreturn False\ntry:\nself._changes = await self._awatch.__anext__()\nexcept StopAsyncIteration as err:\nself._awatch_stopped_exc = err\nreturn True\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.FileWatcher.receive","title":"<code>receive()</code>  <code>async</code>","text":"<p>Receive a message from the channel.</p> RETURNS DESCRIPTION <code>T</code> <p>The received message.</p> RAISES DESCRIPTION <code>ReceiverStoppedError</code> <p>if there is some problem with the receiver.</p> <code>ReceiverError</code> <p>if there is some problem with the receiver.</p>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.FileWatcher.receive--noqa-dar401-cause-httpsgithubcomterrencepreillydarglintissues181","title":"noqa: DAR401 cause (https://github.com/terrencepreilly/darglint/issues/181)","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_base_classes.py</code> <pre><code>async def receive(self) -&gt; T:\n\"\"\"Receive a message from the channel.\n    Returns:\n        The received message.\n    Raises:\n        ReceiverStoppedError: if there is some problem with the receiver.\n        ReceiverError: if there is some problem with the receiver.\n    # noqa: DAR401 __cause__ (https://github.com/terrencepreilly/darglint/issues/181)\n    \"\"\"\ntry:\nreceived = await self.__anext__()  # pylint: disable=unnecessary-dunder-call\nexcept StopAsyncIteration as exc:\n# If we already had a cause and it was the receiver was stopped,\n# then reuse that error, as StopAsyncIteration is just an artifact\n# introduced by __anext__.\nif (\nisinstance(exc.__cause__, ReceiverStoppedError)\n# pylint is not smart enough to figure out we checked above\n# this is a ReceiverStoppedError and thus it does have\n# a receiver member\nand exc.__cause__.receiver is self  # pylint: disable=no-member\n):\nraise exc.__cause__\nraise ReceiverStoppedError(self) from exc\nreturn received\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.Merge","title":"<code>frequenz.channels.util.Merge</code>","text":"<p>             Bases: <code>Receiver[T]</code></p> <p>Merge messages coming from multiple channels into a single stream.</p> Example <p>For example, if there are two channel receivers with the same type, they can be awaited together, and their results merged into a single stream, by using <code>Merge</code> like this:</p> <pre><code>from frequenz.channels import Broadcast\nchannel1 = Broadcast[int](\"input-chan-1\")\nchannel2 = Broadcast[int](\"input-chan-2\")\nreceiver1 = channel1.new_receiver()\nreceiver2 = channel2.new_receiver()\nmerge = Merge(receiver1, receiver2)\nwhile msg := await merge.receive():\n# do something with msg\npass\n</code></pre> <p>When <code>merge</code> is no longer needed, then it should be stopped using <code>self.stop()</code> method. This will cleanup any internal pending async tasks.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/util/_merge.py</code> <pre><code>class Merge(Receiver[T]):\n\"\"\"Merge messages coming from multiple channels into a single stream.\n    Example:\n        For example, if there are two channel receivers with the same type,\n        they can be awaited together, and their results merged into a single\n        stream, by using `Merge` like this:\n        ```python\n        from frequenz.channels import Broadcast\n        channel1 = Broadcast[int](\"input-chan-1\")\n        channel2 = Broadcast[int](\"input-chan-2\")\n        receiver1 = channel1.new_receiver()\n        receiver2 = channel2.new_receiver()\n        merge = Merge(receiver1, receiver2)\n        while msg := await merge.receive():\n            # do something with msg\n            pass\n        ```\n        When `merge` is no longer needed, then it should be stopped using\n        `self.stop()` method. This will cleanup any internal pending async tasks.\n    \"\"\"\ndef __init__(self, *args: Receiver[T]) -&gt; None:\n\"\"\"Create a `Merge` instance.\n        Args:\n            *args: sequence of channel receivers.\n        \"\"\"\nself._receivers = {str(id): recv for id, recv in enumerate(args)}\nself._pending: Set[asyncio.Task[Any]] = {\nasyncio.create_task(recv.__anext__(), name=name)\nfor name, recv in self._receivers.items()\n}\nself._results: Deque[T] = deque(maxlen=len(self._receivers))\ndef __del__(self) -&gt; None:\n\"\"\"Cleanup any pending tasks.\"\"\"\nfor task in self._pending:\nif not task.done() and task.get_loop().is_running():\ntask.cancel()\nasync def stop(self) -&gt; None:\n\"\"\"Stop the `Merge` instance and cleanup any pending tasks.\"\"\"\nfor task in self._pending:\ntask.cancel()\nawait asyncio.gather(*self._pending, return_exceptions=True)\nself._pending = set()\nasync def ready(self) -&gt; bool:\n\"\"\"Wait until the receiver is ready with a value or an error.\n        Once a call to `ready()` has finished, the value should be read with\n        a call to `consume()` (`receive()` or iterated over). The receiver will\n        remain ready (this method will return immediately) until it is\n        consumed.\n        Returns:\n            Whether the receiver is still active.\n        \"\"\"\n# we use a while loop to continue to wait for new data, in case the\n# previous `wait` completed because a channel was closed.\nwhile True:\n# if there are messages waiting to be consumed, return immediately.\nif len(self._results) &gt; 0:\nreturn True\n# if there are no more pending receivers, we return immediately.\nif len(self._pending) == 0:\nreturn False\ndone, self._pending = await asyncio.wait(\nself._pending, return_when=asyncio.FIRST_COMPLETED\n)\nfor item in done:\nname = item.get_name()\n# if channel is closed, don't add a task for it again.\nif isinstance(item.exception(), StopAsyncIteration):\ncontinue\nresult = item.result()\nself._results.append(result)\nself._pending.add(\n# pylint: disable=unnecessary-dunder-call\nasyncio.create_task(self._receivers[name].__anext__(), name=name)\n)\ndef consume(self) -&gt; T:\n\"\"\"Return the latest value once `ready` is complete.\n        Returns:\n            The next value that was received.\n        Raises:\n            ReceiverStoppedError: if the receiver stopped producing messages.\n            ReceiverError: if there is some problem with the receiver.\n        \"\"\"\nif not self._results and not self._pending:\nraise ReceiverStoppedError(self)\nassert self._results, \"`consume()` must be preceeded by a call to `ready()`\"\nreturn self._results.popleft()\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.Merge-functions","title":"Functions","text":""},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.Merge.__aiter__","title":"<code>__aiter__()</code>","text":"<p>Initialize the async iterator over received values.</p> RETURNS DESCRIPTION <code>Receiver[T]</code> <p><code>self</code>, since no extra setup is needed for the iterator.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_base_classes.py</code> <pre><code>def __aiter__(self) -&gt; Receiver[T]:\n\"\"\"Initialize the async iterator over received values.\n    Returns:\n        `self`, since no extra setup is needed for the iterator.\n    \"\"\"\nreturn self\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.Merge.__anext__","title":"<code>__anext__()</code>  <code>async</code>","text":"<p>Await the next value in the async iteration over received values.</p> RETURNS DESCRIPTION <code>T</code> <p>The next value received.</p> RAISES DESCRIPTION <code>StopAsyncIteration</code> <p>if the receiver stopped producing messages.</p> <code>ReceiverError</code> <p>if there is some problem with the receiver.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_base_classes.py</code> <pre><code>async def __anext__(self) -&gt; T:\n\"\"\"Await the next value in the async iteration over received values.\n    Returns:\n        The next value received.\n    Raises:\n        StopAsyncIteration: if the receiver stopped producing messages.\n        ReceiverError: if there is some problem with the receiver.\n    \"\"\"\ntry:\nawait self.ready()\nreturn self.consume()\nexcept ReceiverStoppedError as exc:\nraise StopAsyncIteration() from exc\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.Merge.__del__","title":"<code>__del__()</code>","text":"<p>Cleanup any pending tasks.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/util/_merge.py</code> <pre><code>def __del__(self) -&gt; None:\n\"\"\"Cleanup any pending tasks.\"\"\"\nfor task in self._pending:\nif not task.done() and task.get_loop().is_running():\ntask.cancel()\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.Merge.__init__","title":"<code>__init__(*args)</code>","text":"<p>Create a <code>Merge</code> instance.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>sequence of channel receivers.</p> <p> TYPE: <code>Receiver[T]</code> DEFAULT: <code>()</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/util/_merge.py</code> <pre><code>def __init__(self, *args: Receiver[T]) -&gt; None:\n\"\"\"Create a `Merge` instance.\n    Args:\n        *args: sequence of channel receivers.\n    \"\"\"\nself._receivers = {str(id): recv for id, recv in enumerate(args)}\nself._pending: Set[asyncio.Task[Any]] = {\nasyncio.create_task(recv.__anext__(), name=name)\nfor name, recv in self._receivers.items()\n}\nself._results: Deque[T] = deque(maxlen=len(self._receivers))\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.Merge.consume","title":"<code>consume()</code>","text":"<p>Return the latest value once <code>ready</code> is complete.</p> RETURNS DESCRIPTION <code>T</code> <p>The next value that was received.</p> RAISES DESCRIPTION <code>ReceiverStoppedError</code> <p>if the receiver stopped producing messages.</p> <code>ReceiverError</code> <p>if there is some problem with the receiver.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/util/_merge.py</code> <pre><code>def consume(self) -&gt; T:\n\"\"\"Return the latest value once `ready` is complete.\n    Returns:\n        The next value that was received.\n    Raises:\n        ReceiverStoppedError: if the receiver stopped producing messages.\n        ReceiverError: if there is some problem with the receiver.\n    \"\"\"\nif not self._results and not self._pending:\nraise ReceiverStoppedError(self)\nassert self._results, \"`consume()` must be preceeded by a call to `ready()`\"\nreturn self._results.popleft()\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.Merge.into_peekable","title":"<code>into_peekable()</code>","text":"<p>Convert the <code>Receiver</code> implementation into a <code>Peekable</code>.</p> <p>Once this function has been called, the receiver will no longer be usable, and calling <code>receive</code> on the receiver will raise an exception.</p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>when a <code>Receiver</code> implementation doesn't have a custom <code>into_peekable</code> implementation.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_base_classes.py</code> <pre><code>def into_peekable(self) -&gt; Peekable[T]:\n\"\"\"Convert the `Receiver` implementation into a `Peekable`.\n    Once this function has been called, the receiver will no longer be\n    usable, and calling `receive` on the receiver will raise an exception.\n    Raises:\n        NotImplementedError: when a `Receiver` implementation doesn't have\n            a custom `into_peekable` implementation.\n    \"\"\"\nraise NotImplementedError(\"This receiver does not implement `into_peekable`\")\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.Merge.map","title":"<code>map(call)</code>","text":"<p>Return a receiver with <code>call</code> applied on incoming messages.</p> PARAMETER  DESCRIPTION <code>call</code> <p>function to apply on incoming messages.</p> <p> TYPE: <code>Callable[[T], U]</code> </p> RETURNS DESCRIPTION <code>Receiver[U]</code> <p>A <code>Receiver</code> to read results of the given function from.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_base_classes.py</code> <pre><code>def map(self, call: Callable[[T], U]) -&gt; Receiver[U]:\n\"\"\"Return a receiver with `call` applied on incoming messages.\n    Args:\n        call: function to apply on incoming messages.\n    Returns:\n        A `Receiver` to read results of the given function from.\n    \"\"\"\nreturn _Map(self, call)\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.Merge.ready","title":"<code>ready()</code>  <code>async</code>","text":"<p>Wait until the receiver is ready with a value or an error.</p> <p>Once a call to <code>ready()</code> has finished, the value should be read with a call to <code>consume()</code> (<code>receive()</code> or iterated over). The receiver will remain ready (this method will return immediately) until it is consumed.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the receiver is still active.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/util/_merge.py</code> <pre><code>async def ready(self) -&gt; bool:\n\"\"\"Wait until the receiver is ready with a value or an error.\n    Once a call to `ready()` has finished, the value should be read with\n    a call to `consume()` (`receive()` or iterated over). The receiver will\n    remain ready (this method will return immediately) until it is\n    consumed.\n    Returns:\n        Whether the receiver is still active.\n    \"\"\"\n# we use a while loop to continue to wait for new data, in case the\n# previous `wait` completed because a channel was closed.\nwhile True:\n# if there are messages waiting to be consumed, return immediately.\nif len(self._results) &gt; 0:\nreturn True\n# if there are no more pending receivers, we return immediately.\nif len(self._pending) == 0:\nreturn False\ndone, self._pending = await asyncio.wait(\nself._pending, return_when=asyncio.FIRST_COMPLETED\n)\nfor item in done:\nname = item.get_name()\n# if channel is closed, don't add a task for it again.\nif isinstance(item.exception(), StopAsyncIteration):\ncontinue\nresult = item.result()\nself._results.append(result)\nself._pending.add(\n# pylint: disable=unnecessary-dunder-call\nasyncio.create_task(self._receivers[name].__anext__(), name=name)\n)\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.Merge.receive","title":"<code>receive()</code>  <code>async</code>","text":"<p>Receive a message from the channel.</p> RETURNS DESCRIPTION <code>T</code> <p>The received message.</p> RAISES DESCRIPTION <code>ReceiverStoppedError</code> <p>if there is some problem with the receiver.</p> <code>ReceiverError</code> <p>if there is some problem with the receiver.</p>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.Merge.receive--noqa-dar401-cause-httpsgithubcomterrencepreillydarglintissues181","title":"noqa: DAR401 cause (https://github.com/terrencepreilly/darglint/issues/181)","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_base_classes.py</code> <pre><code>async def receive(self) -&gt; T:\n\"\"\"Receive a message from the channel.\n    Returns:\n        The received message.\n    Raises:\n        ReceiverStoppedError: if there is some problem with the receiver.\n        ReceiverError: if there is some problem with the receiver.\n    # noqa: DAR401 __cause__ (https://github.com/terrencepreilly/darglint/issues/181)\n    \"\"\"\ntry:\nreceived = await self.__anext__()  # pylint: disable=unnecessary-dunder-call\nexcept StopAsyncIteration as exc:\n# If we already had a cause and it was the receiver was stopped,\n# then reuse that error, as StopAsyncIteration is just an artifact\n# introduced by __anext__.\nif (\nisinstance(exc.__cause__, ReceiverStoppedError)\n# pylint is not smart enough to figure out we checked above\n# this is a ReceiverStoppedError and thus it does have\n# a receiver member\nand exc.__cause__.receiver is self  # pylint: disable=no-member\n):\nraise exc.__cause__\nraise ReceiverStoppedError(self) from exc\nreturn received\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.Merge.stop","title":"<code>stop()</code>  <code>async</code>","text":"<p>Stop the <code>Merge</code> instance and cleanup any pending tasks.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/util/_merge.py</code> <pre><code>async def stop(self) -&gt; None:\n\"\"\"Stop the `Merge` instance and cleanup any pending tasks.\"\"\"\nfor task in self._pending:\ntask.cancel()\nawait asyncio.gather(*self._pending, return_exceptions=True)\nself._pending = set()\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.MergeNamed","title":"<code>frequenz.channels.util.MergeNamed</code>","text":"<p>             Bases: <code>Receiver[Tuple[str, T]]</code></p> <p>Merge messages coming from multiple named channels into a single stream.</p> <p>When <code>MergeNamed</code> is no longer needed, then it should be stopped using <code>self.stop()</code> method. This will cleanup any internal pending async tasks.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/util/_merge_named.py</code> <pre><code>class MergeNamed(Receiver[Tuple[str, T]]):\n\"\"\"Merge messages coming from multiple named channels into a single stream.\n    When `MergeNamed` is no longer needed, then it should be stopped using\n    `self.stop()` method. This will cleanup any internal pending async tasks.\n    \"\"\"\ndef __init__(self, **kwargs: Receiver[T]) -&gt; None:\n\"\"\"Create a `MergeNamed` instance.\n        Args:\n            **kwargs: sequence of channel receivers.\n        \"\"\"\nself._receivers = kwargs\nself._pending: Set[asyncio.Task[Any]] = {\nasyncio.create_task(recv.__anext__(), name=name)\nfor name, recv in self._receivers.items()\n}\nself._results: Deque[Tuple[str, T]] = deque(maxlen=len(self._receivers))\ndef __del__(self) -&gt; None:\n\"\"\"Cleanup any pending tasks.\"\"\"\nfor task in self._pending:\nif not task.done() and task.get_loop().is_running():\ntask.cancel()\nasync def stop(self) -&gt; None:\n\"\"\"Stop the `MergeNamed` instance and cleanup any pending tasks.\"\"\"\nfor task in self._pending:\ntask.cancel()\nawait asyncio.gather(*self._pending, return_exceptions=True)\nself._pending = set()\nasync def ready(self) -&gt; bool:\n\"\"\"Wait until the receiver is ready with a value or an error.\n        Once a call to `ready()` has finished, the value should be read with\n        a call to `consume()` (`receive()` or iterated over). The receiver will\n        remain ready (this method will return immediately) until it is\n        consumed.\n        Returns:\n            Whether the receiver is still active.\n        \"\"\"\n# we use a while loop to continue to wait for new data, in case the\n# previous `wait` completed because a channel was closed.\nwhile True:\n# if there are messages waiting to be consumed, return immediately.\nif len(self._results) &gt; 0:\nreturn True\n# if there are no more pending receivers, we return immediately.\nif len(self._pending) == 0:\nreturn False\ndone, self._pending = await asyncio.wait(\nself._pending, return_when=asyncio.FIRST_COMPLETED\n)\nfor item in done:\nname = item.get_name()\n# if channel is closed, don't add a task for it again.\nif isinstance(item.exception(), StopAsyncIteration):\ncontinue\nresult = item.result()\nself._results.append((name, result))\nself._pending.add(\n# pylint: disable=unnecessary-dunder-call\nasyncio.create_task(self._receivers[name].__anext__(), name=name)\n)\ndef consume(self) -&gt; Tuple[str, T]:\n\"\"\"Return the latest value once `ready` is complete.\n        Returns:\n            The next key, value that was received.\n        Raises:\n            ReceiverStoppedError: if the receiver stopped producing messages.\n            ReceiverError: if there is some problem with the receiver.\n        \"\"\"\nif not self._results and not self._pending:\nraise ReceiverStoppedError(self)\nassert self._results, \"`consume()` must be preceeded by a call to `ready()`\"\nreturn self._results.popleft()\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.MergeNamed-functions","title":"Functions","text":""},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.MergeNamed.__aiter__","title":"<code>__aiter__()</code>","text":"<p>Initialize the async iterator over received values.</p> RETURNS DESCRIPTION <code>Receiver[T]</code> <p><code>self</code>, since no extra setup is needed for the iterator.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_base_classes.py</code> <pre><code>def __aiter__(self) -&gt; Receiver[T]:\n\"\"\"Initialize the async iterator over received values.\n    Returns:\n        `self`, since no extra setup is needed for the iterator.\n    \"\"\"\nreturn self\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.MergeNamed.__anext__","title":"<code>__anext__()</code>  <code>async</code>","text":"<p>Await the next value in the async iteration over received values.</p> RETURNS DESCRIPTION <code>T</code> <p>The next value received.</p> RAISES DESCRIPTION <code>StopAsyncIteration</code> <p>if the receiver stopped producing messages.</p> <code>ReceiverError</code> <p>if there is some problem with the receiver.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_base_classes.py</code> <pre><code>async def __anext__(self) -&gt; T:\n\"\"\"Await the next value in the async iteration over received values.\n    Returns:\n        The next value received.\n    Raises:\n        StopAsyncIteration: if the receiver stopped producing messages.\n        ReceiverError: if there is some problem with the receiver.\n    \"\"\"\ntry:\nawait self.ready()\nreturn self.consume()\nexcept ReceiverStoppedError as exc:\nraise StopAsyncIteration() from exc\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.MergeNamed.__del__","title":"<code>__del__()</code>","text":"<p>Cleanup any pending tasks.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/util/_merge_named.py</code> <pre><code>def __del__(self) -&gt; None:\n\"\"\"Cleanup any pending tasks.\"\"\"\nfor task in self._pending:\nif not task.done() and task.get_loop().is_running():\ntask.cancel()\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.MergeNamed.__init__","title":"<code>__init__(**kwargs)</code>","text":"<p>Create a <code>MergeNamed</code> instance.</p> PARAMETER  DESCRIPTION <code>**kwargs</code> <p>sequence of channel receivers.</p> <p> TYPE: <code>Receiver[T]</code> DEFAULT: <code>{}</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/util/_merge_named.py</code> <pre><code>def __init__(self, **kwargs: Receiver[T]) -&gt; None:\n\"\"\"Create a `MergeNamed` instance.\n    Args:\n        **kwargs: sequence of channel receivers.\n    \"\"\"\nself._receivers = kwargs\nself._pending: Set[asyncio.Task[Any]] = {\nasyncio.create_task(recv.__anext__(), name=name)\nfor name, recv in self._receivers.items()\n}\nself._results: Deque[Tuple[str, T]] = deque(maxlen=len(self._receivers))\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.MergeNamed.consume","title":"<code>consume()</code>","text":"<p>Return the latest value once <code>ready</code> is complete.</p> RETURNS DESCRIPTION <code>Tuple[str, T]</code> <p>The next key, value that was received.</p> RAISES DESCRIPTION <code>ReceiverStoppedError</code> <p>if the receiver stopped producing messages.</p> <code>ReceiverError</code> <p>if there is some problem with the receiver.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/util/_merge_named.py</code> <pre><code>def consume(self) -&gt; Tuple[str, T]:\n\"\"\"Return the latest value once `ready` is complete.\n    Returns:\n        The next key, value that was received.\n    Raises:\n        ReceiverStoppedError: if the receiver stopped producing messages.\n        ReceiverError: if there is some problem with the receiver.\n    \"\"\"\nif not self._results and not self._pending:\nraise ReceiverStoppedError(self)\nassert self._results, \"`consume()` must be preceeded by a call to `ready()`\"\nreturn self._results.popleft()\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.MergeNamed.into_peekable","title":"<code>into_peekable()</code>","text":"<p>Convert the <code>Receiver</code> implementation into a <code>Peekable</code>.</p> <p>Once this function has been called, the receiver will no longer be usable, and calling <code>receive</code> on the receiver will raise an exception.</p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>when a <code>Receiver</code> implementation doesn't have a custom <code>into_peekable</code> implementation.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_base_classes.py</code> <pre><code>def into_peekable(self) -&gt; Peekable[T]:\n\"\"\"Convert the `Receiver` implementation into a `Peekable`.\n    Once this function has been called, the receiver will no longer be\n    usable, and calling `receive` on the receiver will raise an exception.\n    Raises:\n        NotImplementedError: when a `Receiver` implementation doesn't have\n            a custom `into_peekable` implementation.\n    \"\"\"\nraise NotImplementedError(\"This receiver does not implement `into_peekable`\")\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.MergeNamed.map","title":"<code>map(call)</code>","text":"<p>Return a receiver with <code>call</code> applied on incoming messages.</p> PARAMETER  DESCRIPTION <code>call</code> <p>function to apply on incoming messages.</p> <p> TYPE: <code>Callable[[T], U]</code> </p> RETURNS DESCRIPTION <code>Receiver[U]</code> <p>A <code>Receiver</code> to read results of the given function from.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_base_classes.py</code> <pre><code>def map(self, call: Callable[[T], U]) -&gt; Receiver[U]:\n\"\"\"Return a receiver with `call` applied on incoming messages.\n    Args:\n        call: function to apply on incoming messages.\n    Returns:\n        A `Receiver` to read results of the given function from.\n    \"\"\"\nreturn _Map(self, call)\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.MergeNamed.ready","title":"<code>ready()</code>  <code>async</code>","text":"<p>Wait until the receiver is ready with a value or an error.</p> <p>Once a call to <code>ready()</code> has finished, the value should be read with a call to <code>consume()</code> (<code>receive()</code> or iterated over). The receiver will remain ready (this method will return immediately) until it is consumed.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the receiver is still active.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/util/_merge_named.py</code> <pre><code>async def ready(self) -&gt; bool:\n\"\"\"Wait until the receiver is ready with a value or an error.\n    Once a call to `ready()` has finished, the value should be read with\n    a call to `consume()` (`receive()` or iterated over). The receiver will\n    remain ready (this method will return immediately) until it is\n    consumed.\n    Returns:\n        Whether the receiver is still active.\n    \"\"\"\n# we use a while loop to continue to wait for new data, in case the\n# previous `wait` completed because a channel was closed.\nwhile True:\n# if there are messages waiting to be consumed, return immediately.\nif len(self._results) &gt; 0:\nreturn True\n# if there are no more pending receivers, we return immediately.\nif len(self._pending) == 0:\nreturn False\ndone, self._pending = await asyncio.wait(\nself._pending, return_when=asyncio.FIRST_COMPLETED\n)\nfor item in done:\nname = item.get_name()\n# if channel is closed, don't add a task for it again.\nif isinstance(item.exception(), StopAsyncIteration):\ncontinue\nresult = item.result()\nself._results.append((name, result))\nself._pending.add(\n# pylint: disable=unnecessary-dunder-call\nasyncio.create_task(self._receivers[name].__anext__(), name=name)\n)\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.MergeNamed.receive","title":"<code>receive()</code>  <code>async</code>","text":"<p>Receive a message from the channel.</p> RETURNS DESCRIPTION <code>T</code> <p>The received message.</p> RAISES DESCRIPTION <code>ReceiverStoppedError</code> <p>if there is some problem with the receiver.</p> <code>ReceiverError</code> <p>if there is some problem with the receiver.</p>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.MergeNamed.receive--noqa-dar401-cause-httpsgithubcomterrencepreillydarglintissues181","title":"noqa: DAR401 cause (https://github.com/terrencepreilly/darglint/issues/181)","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_base_classes.py</code> <pre><code>async def receive(self) -&gt; T:\n\"\"\"Receive a message from the channel.\n    Returns:\n        The received message.\n    Raises:\n        ReceiverStoppedError: if there is some problem with the receiver.\n        ReceiverError: if there is some problem with the receiver.\n    # noqa: DAR401 __cause__ (https://github.com/terrencepreilly/darglint/issues/181)\n    \"\"\"\ntry:\nreceived = await self.__anext__()  # pylint: disable=unnecessary-dunder-call\nexcept StopAsyncIteration as exc:\n# If we already had a cause and it was the receiver was stopped,\n# then reuse that error, as StopAsyncIteration is just an artifact\n# introduced by __anext__.\nif (\nisinstance(exc.__cause__, ReceiverStoppedError)\n# pylint is not smart enough to figure out we checked above\n# this is a ReceiverStoppedError and thus it does have\n# a receiver member\nand exc.__cause__.receiver is self  # pylint: disable=no-member\n):\nraise exc.__cause__\nraise ReceiverStoppedError(self) from exc\nreturn received\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.MergeNamed.stop","title":"<code>stop()</code>  <code>async</code>","text":"<p>Stop the <code>MergeNamed</code> instance and cleanup any pending tasks.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/util/_merge_named.py</code> <pre><code>async def stop(self) -&gt; None:\n\"\"\"Stop the `MergeNamed` instance and cleanup any pending tasks.\"\"\"\nfor task in self._pending:\ntask.cancel()\nawait asyncio.gather(*self._pending, return_exceptions=True)\nself._pending = set()\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.MissedTickPolicy","title":"<code>frequenz.channels.util.MissedTickPolicy</code>","text":"<p>             Bases: <code>ABC</code></p> <p>A policy to handle timer missed ticks.</p> <p>This is only relevant if the timer is not ready to trigger when it should (an interval passed) which can happen if the event loop is busy processing other tasks.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/util/_timer.py</code> <pre><code>class MissedTickPolicy(abc.ABC):\n\"\"\"A policy to handle timer missed ticks.\n    This is only relevant if the timer is not ready to trigger when it should\n    (an interval passed) which can happen if the event loop is busy processing\n    other tasks.\n    \"\"\"\n@abc.abstractmethod\ndef calculate_next_tick_time(\nself, *, interval: int, scheduled_tick_time: int, now: int\n) -&gt; int:\n\"\"\"Calculate the next tick time according to `missed_tick_policy`.\n        This method is called by `ready()` after it has determined that the\n        timer has triggered.  It will check if the timer has missed any ticks\n        and handle them according to `missed_tick_policy`.\n        Args:\n            interval: The interval between ticks (in microseconds).\n            scheduled_tick_time: The time the current tick was scheduled to\n                trigger (in microseconds).\n            now: The current loop time (in microseconds).\n        Returns:\n            The next tick time (in microseconds) according to\n                `missed_tick_policy`.\n        \"\"\"\nreturn 0  # dummy value to avoid darglint warnings\ndef __repr__(self) -&gt; str:\n\"\"\"Return a string representation of the instance.\n        Returns:\n            The string representation of the instance.\n        \"\"\"\nreturn f\"{type(self).__name__}()\"\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.MissedTickPolicy-functions","title":"Functions","text":""},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.MissedTickPolicy.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a string representation of the instance.</p> RETURNS DESCRIPTION <code>str</code> <p>The string representation of the instance.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/util/_timer.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Return a string representation of the instance.\n    Returns:\n        The string representation of the instance.\n    \"\"\"\nreturn f\"{type(self).__name__}()\"\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.MissedTickPolicy.calculate_next_tick_time","title":"<code>calculate_next_tick_time(*, interval, scheduled_tick_time, now)</code>  <code>abstractmethod</code>","text":"<p>Calculate the next tick time according to <code>missed_tick_policy</code>.</p> <p>This method is called by <code>ready()</code> after it has determined that the timer has triggered.  It will check if the timer has missed any ticks and handle them according to <code>missed_tick_policy</code>.</p> PARAMETER  DESCRIPTION <code>interval</code> <p>The interval between ticks (in microseconds).</p> <p> TYPE: <code>int</code> </p> <code>scheduled_tick_time</code> <p>The time the current tick was scheduled to trigger (in microseconds).</p> <p> TYPE: <code>int</code> </p> <code>now</code> <p>The current loop time (in microseconds).</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>int</code> <p>The next tick time (in microseconds) according to <code>missed_tick_policy</code>.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/util/_timer.py</code> <pre><code>@abc.abstractmethod\ndef calculate_next_tick_time(\nself, *, interval: int, scheduled_tick_time: int, now: int\n) -&gt; int:\n\"\"\"Calculate the next tick time according to `missed_tick_policy`.\n    This method is called by `ready()` after it has determined that the\n    timer has triggered.  It will check if the timer has missed any ticks\n    and handle them according to `missed_tick_policy`.\n    Args:\n        interval: The interval between ticks (in microseconds).\n        scheduled_tick_time: The time the current tick was scheduled to\n            trigger (in microseconds).\n        now: The current loop time (in microseconds).\n    Returns:\n        The next tick time (in microseconds) according to\n            `missed_tick_policy`.\n    \"\"\"\nreturn 0  # dummy value to avoid darglint warnings\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.SelectError","title":"<code>frequenz.channels.util.SelectError</code>","text":"<p>             Bases: <code>BaseException</code></p> <p>A base exception for <code>select()</code>.</p> <p>This exception is raised when a <code>select()</code> iteration fails.  It is raised as a single exception when one receiver fails during normal operation (while calling <code>ready()</code> for example).  It is raised as a group exception (<code>SelectErrorGroup</code>) when a <code>select</code> loop is cleaning up after it's done.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/util/_select.py</code> <pre><code>class SelectError(BaseException):\n\"\"\"A base exception for [`select()`][frequenz.channels.util.select].\n    This exception is raised when a `select()` iteration fails.  It is raised as\n    a single exception when one receiver fails during normal operation (while calling\n    `ready()` for example).  It is raised as a group exception\n    ([`SelectErrorGroup`][frequenz.channels.util.SelectErrorGroup]) when a `select` loop\n    is cleaning up after it's done.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.SelectErrorGroup","title":"<code>frequenz.channels.util.SelectErrorGroup</code>","text":"<p>             Bases: <code>BaseExceptionGroup[BaseException]</code>, <code>SelectError</code></p> <p>An exception group for <code>select()</code> operation.</p> <p>This exception group is raised when a <code>select()</code> loops fails while cleaning up runing tasts to check for ready receivers.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/util/_select.py</code> <pre><code>class SelectErrorGroup(BaseExceptionGroup[BaseException], SelectError):\n\"\"\"An exception group for [`select()`][frequenz.channels.util.select] operation.\n    This exception group is raised when a `select()` loops fails while cleaning up\n    runing tasts to check for ready receivers.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.Selected","title":"<code>frequenz.channels.util.Selected</code>","text":"<p>             Bases: <code>Generic[_T]</code></p> <p>A result of a <code>select()</code> iteration.</p> <p>The selected receiver is consumed immediately and the received value is stored in the instance, unless there was an exception while receiving the value, in which case the exception is stored instead.</p> <p><code>Selected</code> instances should be used in conjunction with the <code>selected_from()</code> function to determine which receiver was selected.</p> <p>Please see <code>select()</code> for an example.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/util/_select.py</code> <pre><code>class Selected(Generic[_T]):\n\"\"\"A result of a [`select()`][frequenz.channels.util.select] iteration.\n    The selected receiver is consumed immediately and the received value is stored in\n    the instance, unless there was an exception while receiving the value, in which case\n    the exception is stored instead.\n    `Selected` instances should be used in conjunction with the\n    [`selected_from()`][frequenz.channels.util.selected_from] function to determine\n    which receiver was selected.\n    Please see [`select()`][frequenz.channels.util.select] for an example.\n    \"\"\"\nclass _EmptyResult:\n\"\"\"A sentinel value to distinguish between None and empty result.\n        We need a sentinel because a result can also be `None`.\n        \"\"\"\ndef __repr__(self) -&gt; str:\nreturn \"&lt;empty&gt;\"\ndef __init__(self, receiver: Receiver[_T]) -&gt; None:\n\"\"\"Create a new instance.\n        The receiver is consumed immediately when creating the instance and the received\n        value is stored in the instance for later use as\n        [`value`][frequenz.channels.util.Selected.value].  If there was an exception\n        while receiving the value, then the exception is stored in the instance instead\n        (as [`exception`][frequenz.channels.util.Selected.exception]).\n        Args:\n            receiver: The receiver that was selected.\n        \"\"\"\nself._recv: Receiver[_T] = receiver\n\"\"\"The receiver that was selected.\"\"\"\nself._value: _T | Selected._EmptyResult = Selected._EmptyResult()\n\"\"\"The value that was received.\n        If there was an exception while receiving the value, then this will be `None`.\n        \"\"\"\nself._exception: Exception | None = None\n\"\"\"The exception that was raised while receiving the value (if any).\"\"\"\ntry:\nself._value = receiver.consume()\nexcept Exception as exc:  # pylint: disable=broad-except\nself._exception = exc\nself._handled: bool = False\n\"\"\"Flag to indicate if this selected has been handled in the if-chain.\"\"\"\n@property\ndef value(self) -&gt; _T:\n\"\"\"The value that was received, if any.\n        Returns:\n            The value that was received.\n        Raises:\n            Exception: If there was an exception while receiving the value. Normally\n                this should be an [`frequenz.channels.Error`][frequenz.channels.Error]\n                instance, but catches all exceptions in case some receivers can raise\n                anything else.\n        # noqa: DAR401 _exception\n        \"\"\"\nif self._exception is not None:\nraise self._exception\nassert not isinstance(self._value, Selected._EmptyResult)\nreturn self._value\n@property\ndef exception(self) -&gt; Exception | None:\n\"\"\"The exception that was raised while receiving the value (if any).\n        Returns:\n            The exception that was raised while receiving the value (if any).\n        \"\"\"\nreturn self._exception\ndef was_stopped(self) -&gt; bool:\n\"\"\"Check if the selected receiver was stopped.\n        Check if the selected receiver raised\n        a [`ReceiverStoppedError`][frequenz.channels.ReceiverStoppedError] while\n        consuming a value.\n        Returns:\n            Whether the receiver was stopped.\n        \"\"\"\nreturn isinstance(self._exception, ReceiverStoppedError)\ndef __str__(self) -&gt; str:\n\"\"\"Return a string representation of this instance.\n        Returns:\n            A string representation of this instance.\n        \"\"\"\nreturn (\nf\"{type(self).__name__}({self._recv}) -&gt; \"\nf\"{self._exception or self._value})\"\n)\ndef __repr__(self) -&gt; str:\n\"\"\"Return a the internal representation of this instance.\n        Returns:\n            A string representation of this instance.\n        \"\"\"\nreturn (\nf\"{type(self).__name__}({self._recv=}, {self._value=}, \"\nf\"{self._exception=}, {self._handled=})\"\n)\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.Selected-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.Selected.exception","title":"<code>exception: Exception | None</code>  <code>property</code>","text":"<p>The exception that was raised while receiving the value (if any).</p> RETURNS DESCRIPTION <code>Exception | None</code> <p>The exception that was raised while receiving the value (if any).</p>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.Selected.value","title":"<code>value: _T</code>  <code>property</code>","text":"<p>The value that was received, if any.</p> RETURNS DESCRIPTION <code>_T</code> <p>The value that was received.</p> RAISES DESCRIPTION <code>Exception</code> <p>If there was an exception while receiving the value. Normally this should be an <code>frequenz.channels.Error</code> instance, but catches all exceptions in case some receivers can raise anything else.</p>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.Selected.value--noqa-dar401-_exception","title":"noqa: DAR401 _exception","text":""},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.Selected-functions","title":"Functions","text":""},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.Selected.__init__","title":"<code>__init__(receiver)</code>","text":"<p>Create a new instance.</p> <p>The receiver is consumed immediately when creating the instance and the received value is stored in the instance for later use as <code>value</code>.  If there was an exception while receiving the value, then the exception is stored in the instance instead (as <code>exception</code>).</p> PARAMETER  DESCRIPTION <code>receiver</code> <p>The receiver that was selected.</p> <p> TYPE: <code>Receiver[_T]</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/util/_select.py</code> <pre><code>def __init__(self, receiver: Receiver[_T]) -&gt; None:\n\"\"\"Create a new instance.\n    The receiver is consumed immediately when creating the instance and the received\n    value is stored in the instance for later use as\n    [`value`][frequenz.channels.util.Selected.value].  If there was an exception\n    while receiving the value, then the exception is stored in the instance instead\n    (as [`exception`][frequenz.channels.util.Selected.exception]).\n    Args:\n        receiver: The receiver that was selected.\n    \"\"\"\nself._recv: Receiver[_T] = receiver\n\"\"\"The receiver that was selected.\"\"\"\nself._value: _T | Selected._EmptyResult = Selected._EmptyResult()\n\"\"\"The value that was received.\n    If there was an exception while receiving the value, then this will be `None`.\n    \"\"\"\nself._exception: Exception | None = None\n\"\"\"The exception that was raised while receiving the value (if any).\"\"\"\ntry:\nself._value = receiver.consume()\nexcept Exception as exc:  # pylint: disable=broad-except\nself._exception = exc\nself._handled: bool = False\n\"\"\"Flag to indicate if this selected has been handled in the if-chain.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.Selected.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a the internal representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/util/_select.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Return a the internal representation of this instance.\n    Returns:\n        A string representation of this instance.\n    \"\"\"\nreturn (\nf\"{type(self).__name__}({self._recv=}, {self._value=}, \"\nf\"{self._exception=}, {self._handled=})\"\n)\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.Selected.__str__","title":"<code>__str__()</code>","text":"<p>Return a string representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/util/_select.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Return a string representation of this instance.\n    Returns:\n        A string representation of this instance.\n    \"\"\"\nreturn (\nf\"{type(self).__name__}({self._recv}) -&gt; \"\nf\"{self._exception or self._value})\"\n)\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.Selected.was_stopped","title":"<code>was_stopped()</code>","text":"<p>Check if the selected receiver was stopped.</p> <p>Check if the selected receiver raised a <code>ReceiverStoppedError</code> while consuming a value.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the receiver was stopped.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/util/_select.py</code> <pre><code>def was_stopped(self) -&gt; bool:\n\"\"\"Check if the selected receiver was stopped.\n    Check if the selected receiver raised\n    a [`ReceiverStoppedError`][frequenz.channels.ReceiverStoppedError] while\n    consuming a value.\n    Returns:\n        Whether the receiver was stopped.\n    \"\"\"\nreturn isinstance(self._exception, ReceiverStoppedError)\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.SkipMissedAndDrift","title":"<code>frequenz.channels.util.SkipMissedAndDrift</code>","text":"<p>             Bases: <code>MissedTickPolicy</code></p> <p>A policy that drops all the missed ticks, triggers immediately and resets.</p> <p>This will behave effectively as if the timer was <code>reset()</code> at the time it had triggered last, so the start time will change (and the drift will be accumulated each time a tick is delayed, but only the relative drift will be returned on each tick).</p> <p>The reset happens only if the delay is larger than <code>delay_tolerance</code>, so it is possible to ignore small delays and not drift in those cases.</p> Example <p>Assume a timer with interval 1 second and <code>delay_tolerance=0.1</code>, the first tick, <code>T0</code>, happens exactly at time 0, the second tick, <code>T1</code>, happens at time 1.2 (0.2 seconds late), so the timer triggers immmediately but drifts a bit. The next tick, <code>T2.2</code>, happens at 2.3 seconds (0.1 seconds late), so it also triggers immediately but it doesn't drift because the delay is under the <code>delay_tolerance</code>. The next tick, <code>T3.2</code>, triggers at 4.3 seconds (1.1 seconds late), so it also triggers immediately but the timer drifts by 1.1 seconds and the tick <code>T4.2</code> is skipped (not triggered). The next tick, <code>T5.3</code>, triggers at 5.3 seconds so is right on time (no drift) and the same happens for tick <code>T6.3</code>, which triggers at 6.3 seconds.</p> <pre><code>0         1         2         3         4         5         6\no---------|-o-------|--o------|---------|--o------|--o------|--o--&gt; time\nT0          T1         T2.2                T3.2      T5.3      T6.3\n</code></pre> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/util/_timer.py</code> <pre><code>class SkipMissedAndDrift(MissedTickPolicy):\n\"\"\"A policy that drops all the missed ticks, triggers immediately and resets.\n    This will behave effectively as if the timer was `reset()` at the time it\n    had triggered last, so the start time will change (and the drift will be\n    accumulated each time a tick is delayed, but only the relative drift will\n    be returned on each tick).\n    The reset happens only if the delay is larger than `delay_tolerance`, so\n    it is possible to ignore small delays and not drift in those cases.\n    Example:\n        Assume a timer with interval 1 second and `delay_tolerance=0.1`, the\n        first tick, `T0`, happens exactly at time 0, the second tick, `T1`,\n        happens at time 1.2 (0.2 seconds late), so the timer triggers\n        immmediately but drifts a bit. The next tick, `T2.2`, happens at 2.3 seconds\n        (0.1 seconds late), so it also triggers immediately but it doesn't\n        drift because the delay is under the `delay_tolerance`. The next tick,\n        `T3.2`, triggers at 4.3 seconds (1.1 seconds late), so it also triggers\n        immediately but the timer drifts by 1.1 seconds and the tick `T4.2` is\n        skipped (not triggered). The next tick, `T5.3`, triggers at 5.3 seconds\n        so is right on time (no drift) and the same happens for tick `T6.3`,\n        which triggers at 6.3 seconds.\n        ```\n        0         1         2         3         4         5         6\n        o---------|-o-------|--o------|---------|--o------|--o------|--o--&gt; time\n        T0          T1         T2.2                T3.2      T5.3      T6.3\n        ```\n    \"\"\"\ndef __init__(self, *, delay_tolerance: timedelta = timedelta(0)):\n\"\"\"\n        Create an instance.\n        See the class documenation for more details.\n        Args:\n            delay_tolerance: The maximum delay that is tolerated before\n                starting to drift.  If a tick is delayed less than this, then\n                it is not considered a missed tick and the timer doesn't\n                accumulate this drift.\n        Raises:\n            ValueError: If `delay_tolerance` is negative.\n        \"\"\"\nself._tolerance: int = _to_microseconds(delay_tolerance)\n\"\"\"The maximum allowed delay before starting to drift.\"\"\"\nif self._tolerance &lt; 0:\nraise ValueError(\"delay_tolerance must be positive\")\n@property\ndef delay_tolerance(self) -&gt; timedelta:\n\"\"\"Return the maximum delay that is tolerated before starting to drift.\n        Returns:\n            The maximum delay that is tolerated before starting to drift.\n        \"\"\"\nreturn timedelta(microseconds=self._tolerance)\ndef calculate_next_tick_time(\nself, *, now: int, scheduled_tick_time: int, interval: int\n) -&gt; int:\n\"\"\"Calculate the next tick time.\n        If the drift is larger than `delay_tolerance`, then it returns `now +\n        interval` (so the timer drifts), otherwise it returns\n        `scheduled_tick_time + interval` (we consider the delay too small and\n        avoid small drifts).\n        Args:\n            now: The current loop time (in microseconds).\n            scheduled_tick_time: The time the current tick was scheduled to\n                trigger (in microseconds).\n            interval: The interval between ticks (in microseconds).\n        Returns:\n            The next tick time (in microseconds).\n        \"\"\"\ndrift = now - scheduled_tick_time\nif drift &gt; self._tolerance:\nreturn now + interval\nreturn scheduled_tick_time + interval\ndef __str__(self) -&gt; str:\n\"\"\"Return a string representation of the instance.\n        Returns:\n            The string representation of the instance.\n        \"\"\"\nreturn f\"{type(self).__name__}({self.delay_tolerance})\"\ndef __repr__(self) -&gt; str:\n\"\"\"Return a string representation of the instance.\n        Returns:\n            The string representation of the instance.\n        \"\"\"\nreturn f\"{type(self).__name__}({self.delay_tolerance=})\"\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.SkipMissedAndDrift-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.SkipMissedAndDrift.delay_tolerance","title":"<code>delay_tolerance: timedelta</code>  <code>property</code>","text":"<p>Return the maximum delay that is tolerated before starting to drift.</p> RETURNS DESCRIPTION <code>timedelta</code> <p>The maximum delay that is tolerated before starting to drift.</p>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.SkipMissedAndDrift-functions","title":"Functions","text":""},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.SkipMissedAndDrift.__init__","title":"<code>__init__(*, delay_tolerance=timedelta(0))</code>","text":"<p>Create an instance.</p> <p>See the class documenation for more details.</p> PARAMETER  DESCRIPTION <code>delay_tolerance</code> <p>The maximum delay that is tolerated before starting to drift.  If a tick is delayed less than this, then it is not considered a missed tick and the timer doesn't accumulate this drift.</p> <p> TYPE: <code>timedelta</code> DEFAULT: <code>timedelta(0)</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If <code>delay_tolerance</code> is negative.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/util/_timer.py</code> <pre><code>def __init__(self, *, delay_tolerance: timedelta = timedelta(0)):\n\"\"\"\n    Create an instance.\n    See the class documenation for more details.\n    Args:\n        delay_tolerance: The maximum delay that is tolerated before\n            starting to drift.  If a tick is delayed less than this, then\n            it is not considered a missed tick and the timer doesn't\n            accumulate this drift.\n    Raises:\n        ValueError: If `delay_tolerance` is negative.\n    \"\"\"\nself._tolerance: int = _to_microseconds(delay_tolerance)\n\"\"\"The maximum allowed delay before starting to drift.\"\"\"\nif self._tolerance &lt; 0:\nraise ValueError(\"delay_tolerance must be positive\")\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.SkipMissedAndDrift.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a string representation of the instance.</p> RETURNS DESCRIPTION <code>str</code> <p>The string representation of the instance.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/util/_timer.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Return a string representation of the instance.\n    Returns:\n        The string representation of the instance.\n    \"\"\"\nreturn f\"{type(self).__name__}({self.delay_tolerance=})\"\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.SkipMissedAndDrift.__str__","title":"<code>__str__()</code>","text":"<p>Return a string representation of the instance.</p> RETURNS DESCRIPTION <code>str</code> <p>The string representation of the instance.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/util/_timer.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Return a string representation of the instance.\n    Returns:\n        The string representation of the instance.\n    \"\"\"\nreturn f\"{type(self).__name__}({self.delay_tolerance})\"\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.SkipMissedAndDrift.calculate_next_tick_time","title":"<code>calculate_next_tick_time(*, now, scheduled_tick_time, interval)</code>","text":"<p>Calculate the next tick time.</p> <p>If the drift is larger than <code>delay_tolerance</code>, then it returns <code>now + interval</code> (so the timer drifts), otherwise it returns <code>scheduled_tick_time + interval</code> (we consider the delay too small and avoid small drifts).</p> PARAMETER  DESCRIPTION <code>now</code> <p>The current loop time (in microseconds).</p> <p> TYPE: <code>int</code> </p> <code>scheduled_tick_time</code> <p>The time the current tick was scheduled to trigger (in microseconds).</p> <p> TYPE: <code>int</code> </p> <code>interval</code> <p>The interval between ticks (in microseconds).</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>int</code> <p>The next tick time (in microseconds).</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/util/_timer.py</code> <pre><code>def calculate_next_tick_time(\nself, *, now: int, scheduled_tick_time: int, interval: int\n) -&gt; int:\n\"\"\"Calculate the next tick time.\n    If the drift is larger than `delay_tolerance`, then it returns `now +\n    interval` (so the timer drifts), otherwise it returns\n    `scheduled_tick_time + interval` (we consider the delay too small and\n    avoid small drifts).\n    Args:\n        now: The current loop time (in microseconds).\n        scheduled_tick_time: The time the current tick was scheduled to\n            trigger (in microseconds).\n        interval: The interval between ticks (in microseconds).\n    Returns:\n        The next tick time (in microseconds).\n    \"\"\"\ndrift = now - scheduled_tick_time\nif drift &gt; self._tolerance:\nreturn now + interval\nreturn scheduled_tick_time + interval\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.SkipMissedAndResync","title":"<code>frequenz.channels.util.SkipMissedAndResync</code>","text":"<p>             Bases: <code>MissedTickPolicy</code></p> <p>A policy that drops all the missed ticks, triggers immediately and resyncs.</p> <p>If ticks are missed, the timer will trigger immediately returing the drift and it will schedule to trigger again on the next multiple of <code>interval</code>, effectively skipping any missed ticks, but resyncing with the original start time.</p> Example <p>Assume a timer with interval 1 second, the tick <code>T0</code> happens exactly at time 0, the second tick, <code>T1</code>, happens at time 1.2 (0.2 seconds late), so it trigges immediately.  The third tick, <code>T2</code>, happens at time 2.3 (0.3 seconds late), so it also triggers immediately.  The fourth tick, <code>T3</code>, happens at time 4.3 (1.3 seconds late), so it also triggers immediately but the fifth tick, <code>T4</code>, which was also already delayed (by 0.3 seconds) is skipped.  The sixth tick, <code>T5</code>, happens at 5.1 (0.1 seconds late), so it triggers immediately again. The seventh tick, <code>T6</code>, happens at 6.0, right on time.</p> <pre><code>0         1         2         3         4  o      5         6\no---------|-o-------|--o------|---------|--o------|o--------o-----&gt; time\nT0          T1         T2                  T3      T5       T6\n</code></pre> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/util/_timer.py</code> <pre><code>class SkipMissedAndResync(MissedTickPolicy):\n\"\"\"A policy that drops all the missed ticks, triggers immediately and resyncs.\n    If ticks are missed, the timer will trigger immediately returing the drift\n    and it will schedule to trigger again on the next multiple of `interval`,\n    effectively skipping any missed ticks, but resyncing with the original start\n    time.\n    Example:\n        Assume a timer with interval 1 second, the tick `T0` happens exactly\n        at time 0, the second tick, `T1`, happens at time 1.2 (0.2 seconds\n        late), so it trigges immediately.  The third tick, `T2`, happens at\n        time 2.3 (0.3 seconds late), so it also triggers immediately.  The\n        fourth tick, `T3`, happens at time 4.3 (1.3 seconds late), so it also\n        triggers immediately but the fifth tick, `T4`, which was also\n        already delayed (by 0.3 seconds) is skipped.  The sixth tick,\n        `T5`, happens at 5.1 (0.1 seconds late), so it triggers immediately\n        again. The seventh tick, `T6`, happens at 6.0, right on time.\n        ```\n        0         1         2         3         4  o      5         6\n        o---------|-o-------|--o------|---------|--o------|o--------o-----&gt; time\n        T0          T1         T2                  T3      T5       T6\n        ```\n    \"\"\"\ndef calculate_next_tick_time(\nself, *, now: int, scheduled_tick_time: int, interval: int\n) -&gt; int:\n\"\"\"Calculate the next tick time.\n        Calculate the next multiple of `interval` after `scheduled_tick_time`.\n        Args:\n            now: The current loop time (in microseconds).\n            scheduled_tick_time: The time the current tick was scheduled to\n                trigger (in microseconds).\n            interval: The interval between ticks (in microseconds).\n        Returns:\n            The next tick time (in microseconds).\n        \"\"\"\n# We need to resync (align) the next tick time to the current time\ndrift = now - scheduled_tick_time\ndelta_to_next_tick = interval - (drift % interval)\nreturn now + delta_to_next_tick\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.SkipMissedAndResync-functions","title":"Functions","text":""},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.SkipMissedAndResync.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a string representation of the instance.</p> RETURNS DESCRIPTION <code>str</code> <p>The string representation of the instance.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/util/_timer.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Return a string representation of the instance.\n    Returns:\n        The string representation of the instance.\n    \"\"\"\nreturn f\"{type(self).__name__}()\"\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.SkipMissedAndResync.calculate_next_tick_time","title":"<code>calculate_next_tick_time(*, now, scheduled_tick_time, interval)</code>","text":"<p>Calculate the next tick time.</p> <p>Calculate the next multiple of <code>interval</code> after <code>scheduled_tick_time</code>.</p> PARAMETER  DESCRIPTION <code>now</code> <p>The current loop time (in microseconds).</p> <p> TYPE: <code>int</code> </p> <code>scheduled_tick_time</code> <p>The time the current tick was scheduled to trigger (in microseconds).</p> <p> TYPE: <code>int</code> </p> <code>interval</code> <p>The interval between ticks (in microseconds).</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>int</code> <p>The next tick time (in microseconds).</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/util/_timer.py</code> <pre><code>def calculate_next_tick_time(\nself, *, now: int, scheduled_tick_time: int, interval: int\n) -&gt; int:\n\"\"\"Calculate the next tick time.\n    Calculate the next multiple of `interval` after `scheduled_tick_time`.\n    Args:\n        now: The current loop time (in microseconds).\n        scheduled_tick_time: The time the current tick was scheduled to\n            trigger (in microseconds).\n        interval: The interval between ticks (in microseconds).\n    Returns:\n        The next tick time (in microseconds).\n    \"\"\"\n# We need to resync (align) the next tick time to the current time\ndrift = now - scheduled_tick_time\ndelta_to_next_tick = interval - (drift % interval)\nreturn now + delta_to_next_tick\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.Timer","title":"<code>frequenz.channels.util.Timer</code>","text":"<p>             Bases: <code>Receiver[timedelta]</code></p> <p>A timer receiver that triggers every <code>interval</code> time.</p> <p>The timer has microseconds resolution, so the <code>interval</code> must be at least 1 microsecond.</p> <p>The message it produces is a <code>timedelta</code> containing the drift of the timer, i.e. the difference between when the timer should have triggered and the time when it actually triggered.</p> <p>This drift will likely never be <code>0</code>, because if there is a task that is running when it should trigger, the timer will be delayed. In this case the drift will be positive. A negative drift should be technically impossible, as the timer uses <code>asyncio</code>s loop monotonic clock.</p> <p>If the timer is delayed too much, then it will behave according to the <code>missed_tick_policy</code>. Missing ticks might or might not trigger a message and the drift could be accumulated or not depending on the chosen policy.</p> <p>These are the currently built-in available policies:</p> <ul> <li><code>SkipMissedAndDrift</code></li> <li><code>SkipMissedAndResync</code></li> <li><code>TriggerAllMissed</code></li> </ul> <p>For the most common cases, a specialized constructor is provided:</p> <ul> <li><code>periodic()</code> (uses the   <code>TriggerAllMissed</code> or   <code>SkipMissedAndResync</code> policy)</li> <li><code>timeout()</code> (uses the   <code>SkipMissedAndDrift</code> policy)</li> </ul> <p>The timer accepts an optional <code>loop</code>, which will be used to track the time. If <code>loop</code> is <code>None</code>, then the running loop will be used (if there is no running loop most calls will raise a <code>RuntimeError</code>).</p> <p>Starting the timer can be delayed if necessary by using <code>auto_start=False</code> (for example until we have a running loop). A call to <code>reset()</code>, <code>ready()</code>, <code>receive()</code> or the async iterator interface to await for a new message will start the timer.</p> Periodic timer example <pre><code>async for drift in Timer.periodic(timedelta(seconds=1.0)):\nprint(f\"The timer has triggered {drift=}\")\n</code></pre> <p>But you can also use a <code>select</code> to combine it with other receivers, and even start it (semi) manually:</p> <pre><code>import logging\nfrom frequenz.channels.util import select, selected_from\nfrom frequenz.channels import Broadcast\ntimer = Timer.timeout(timedelta(seconds=1.0), auto_start=False)\nchan = Broadcast[int](\"input-chan\")\nbattery_data = chan.new_receiver()\ntimer = Timer.timeout(timedelta(seconds=1.0), auto_start=False)\n# Do some other initialization, the timer will start automatically if\n# a message is awaited (or manually via `reset()`).\nasync for selected in select(battery_data, timer):\nif selected_from(selected, battery_data):\nif selected.was_closed():\nlogging.warning(\"battery channel closed\")\ncontinue\nbattery_soc = selected.value\nelif selected_from(selected, timer):\n# Print some regular battery data\nprint(f\"Battery is charged at {battery_soc}%\")\n</code></pre> Timeout example <pre><code>import logging\nfrom frequenz.channels.util import select, selected_from\nfrom frequenz.channels import Broadcast\ndef process_data(data: int):\nlogging.info(\"Processing data: %d\", data)\ndef do_heavy_processing(data: int):\nlogging.info(\"Heavy processing data: %d\", data)\ntimer = Timer.timeout(timedelta(seconds=1.0), auto_start=False)\nchan1 = Broadcast[int](\"input-chan-1\")\nchan2 = Broadcast[int](\"input-chan-2\")\nbattery_data = chan1.new_receiver()\nheavy_process = chan2.new_receiver()\nasync for selected in select(battery_data, heavy_process, timer):\nif selected_from(selected, battery_data):\nif selected.was_closed():\nlogging.warning(\"battery channel closed\")\ncontinue\nprocess_data(selected.value)\ntimer.reset()\nelif selected_from(selected, heavy_process):\nif selected.was_closed():\nlogging.warning(\"processing channel closed\")\ncontinue\ndo_heavy_processing(selected.value)\nelif selected_from(selected, timer):\nlogging.warning(\"No data received in time\")\n</code></pre> <p>In this case <code>do_heavy_processing</code> might take 2 seconds, and we don't want our timeout timer to trigger for the missed ticks, and want the next tick to be relative to the time timer was last triggered.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/util/_timer.py</code> <pre><code>class Timer(Receiver[timedelta]):\n\"\"\"A timer receiver that triggers every `interval` time.\n    The timer has microseconds resolution, so the\n    [`interval`][frequenz.channels.util.Timer.interval] must be at least\n    1 microsecond.\n    The message it produces is a [`timedelta`][datetime.timedelta] containing the drift\n    of the timer, i.e. the difference between when the timer should have triggered and\n    the time when it actually triggered.\n    This drift will likely never be `0`, because if there is a task that is\n    running when it should trigger, the timer will be delayed. In this case the\n    drift will be positive. A negative drift should be technically impossible,\n    as the timer uses [`asyncio`][asyncio]s loop monotonic clock.\n    If the timer is delayed too much, then it will behave according to the\n    [`missed_tick_policy`][frequenz.channels.util.Timer.missed_tick_policy]. Missing\n    ticks might or might not trigger a message and the drift could be accumulated or not\n    depending on the chosen policy.\n    These are the currently built-in available policies:\n    * [`SkipMissedAndDrift`][frequenz.channels.util.SkipMissedAndDrift]\n    * [`SkipMissedAndResync`][frequenz.channels.util.SkipMissedAndResync]\n    * [`TriggerAllMissed`][frequenz.channels.util.TriggerAllMissed]\n    For the most common cases, a specialized constructor is provided:\n    * [`periodic()`][frequenz.channels.util.Timer.periodic] (uses the\n      [`TriggerAllMissed`][frequenz.channels.util.TriggerAllMissed] or\n      [`SkipMissedAndResync`][frequenz.channels.util.SkipMissedAndResync] policy)\n    * [`timeout()`][frequenz.channels.util.Timer.timeout] (uses the\n      [`SkipMissedAndDrift`][frequenz.channels.util.SkipMissedAndDrift] policy)\n    The timer accepts an optional [`loop`][frequenz.channels.util.Timer.loop], which\n    will be used to track the time. If `loop` is `None`, then the running loop will be\n    used (if there is no running loop most calls will raise\n    a [`RuntimeError`][RuntimeError]).\n    Starting the timer can be delayed if necessary by using `auto_start=False`\n    (for example until we have a running loop). A call to\n    [`reset()`][frequenz.channels.util.Timer.reset],\n    [`ready()`][frequenz.channels.util.Timer.ready],\n    [`receive()`][frequenz.channels.util.Timer.receive] or the async iterator interface\n    to await for a new message will start the timer.\n    Example: Periodic timer example\n        ```python\n        async for drift in Timer.periodic(timedelta(seconds=1.0)):\n            print(f\"The timer has triggered {drift=}\")\n        ```\n        But you can also use a [`select`][frequenz.channels.util.select] to combine\n        it with other receivers, and even start it (semi) manually:\n        ```python\n        import logging\n        from frequenz.channels.util import select, selected_from\n        from frequenz.channels import Broadcast\n        timer = Timer.timeout(timedelta(seconds=1.0), auto_start=False)\n        chan = Broadcast[int](\"input-chan\")\n        battery_data = chan.new_receiver()\n        timer = Timer.timeout(timedelta(seconds=1.0), auto_start=False)\n        # Do some other initialization, the timer will start automatically if\n        # a message is awaited (or manually via `reset()`).\n        async for selected in select(battery_data, timer):\n            if selected_from(selected, battery_data):\n                if selected.was_closed():\n                    logging.warning(\"battery channel closed\")\n                    continue\n                battery_soc = selected.value\n            elif selected_from(selected, timer):\n                # Print some regular battery data\n                print(f\"Battery is charged at {battery_soc}%\")\n        ```\n    Example: Timeout example\n        ```python\n        import logging\n        from frequenz.channels.util import select, selected_from\n        from frequenz.channels import Broadcast\n        def process_data(data: int):\n            logging.info(\"Processing data: %d\", data)\n        def do_heavy_processing(data: int):\n            logging.info(\"Heavy processing data: %d\", data)\n        timer = Timer.timeout(timedelta(seconds=1.0), auto_start=False)\n        chan1 = Broadcast[int](\"input-chan-1\")\n        chan2 = Broadcast[int](\"input-chan-2\")\n        battery_data = chan1.new_receiver()\n        heavy_process = chan2.new_receiver()\n        async for selected in select(battery_data, heavy_process, timer):\n            if selected_from(selected, battery_data):\n                if selected.was_closed():\n                    logging.warning(\"battery channel closed\")\n                    continue\n                process_data(selected.value)\n                timer.reset()\n            elif selected_from(selected, heavy_process):\n                if selected.was_closed():\n                    logging.warning(\"processing channel closed\")\n                    continue\n                do_heavy_processing(selected.value)\n            elif selected_from(selected, timer):\n                logging.warning(\"No data received in time\")\n        ```\n        In this case `do_heavy_processing` might take 2 seconds, and we don't\n        want our timeout timer to trigger for the missed ticks, and want the\n        next tick to be relative to the time timer was last triggered.\n    \"\"\"\ndef __init__(\nself,\ninterval: timedelta,\nmissed_tick_policy: MissedTickPolicy,\n/,\n*,\nauto_start: bool = True,\nstart_delay: timedelta = timedelta(0),\nloop: asyncio.AbstractEventLoop | None = None,\n) -&gt; None:\n\"\"\"Create an instance.\n        See the class documentation for details.\n        Args:\n            interval: The time between timer ticks. Must be at least\n                1 microsecond.\n            missed_tick_policy: The policy of the timer when it misses a tick.\n                Commonly one of `TriggerAllMissed`, `SkipMissedAndResync`, `SkipMissedAndDrift`\n                or a custom class deriving from `MissedTickPolicy`. See the\n                documentation of the each class for more details.\n            auto_start: Whether the timer should be started when the\n                instance is created. This can only be `True` if there is\n                already a running loop or an explicit `loop` that is running\n                was passed.\n            start_delay: The delay before the timer should start. If `auto_start` is\n                `False`, an exception is raised. This has microseconds resolution,\n                anything smaller than a microsecond means no delay.\n            loop: The event loop to use to track time. If `None`,\n                `asyncio.get_running_loop()` will be used.\n        Raises:\n            RuntimeError: if it was called without a loop and there is no\n                running loop.\n            ValueError: if `interval` is not positive or is smaller than 1\n                microsecond; if `start_delay` is negative or `start_delay` was specified\n                but `auto_start` is `False`.\n        \"\"\"\nif interval &lt; timedelta(microseconds=1):\nraise ValueError(\nf\"The `interval` must be positive and at least 1 microsecond, not {interval}\"\n)\nif start_delay &gt; timedelta(0) and auto_start is False:\nraise ValueError(\n\"`auto_start` must be `True` if a `start_delay` is specified\"\n)\nself._interval: int = _to_microseconds(interval)\n\"\"\"The time to between timer ticks.\"\"\"\nself._missed_tick_policy: MissedTickPolicy = missed_tick_policy\n\"\"\"The policy of the timer when it misses a tick.\n        See the documentation of `MissedTickPolicy` for details.\n        \"\"\"\nself._loop: asyncio.AbstractEventLoop = (\nloop if loop is not None else asyncio.get_running_loop()\n)\n\"\"\"The event loop to use to track time.\"\"\"\nself._stopped: bool = True\n\"\"\"Whether the timer was requested to stop.\n        If this is `False`, then the timer is running.\n        If this is `True`, then it is stopped or there is a request to stop it\n        or it was not started yet:\n        * If `_next_msg_time` is `None`, it means it wasn't started yet (it was\n          created with `auto_start=False`).  Any receiving method will start\n          it by calling `reset()` in this case.\n        * If `_next_msg_time` is not `None`, it means there was a request to\n          stop it.  In this case receiving methods will raise\n          a `ReceiverClosedError`.\n        \"\"\"\nself._next_tick_time: int | None = None\n\"\"\"The absolute (monotonic) time when the timer should trigger.\n        If this is `None`, it means the timer didn't start yet, but it should\n        be started as soon as it is used.\n        \"\"\"\nself._current_drift: timedelta | None = None\n\"\"\"The difference between `_next_msg_time` and the triggered time.\n        This is calculated by `ready()` but is returned by `consume()`. If\n        `None` it means `ready()` wasn't called and `consume()` will assert.\n        `consume()` will set it back to `None` to tell `ready()` that it needs\n        to wait again.\n        \"\"\"\nif auto_start:\nself.reset(start_delay=start_delay)\n@classmethod\ndef timeout(\ncls,\ndelay: timedelta,\n/,\n*,\nauto_start: bool = True,\nstart_delay: timedelta = timedelta(0),\nloop: asyncio.AbstractEventLoop | None = None,\n) -&gt; Timer:\n\"\"\"Create a timer useful for tracking timeouts.\n        This is basically a shortcut to create a timer with\n        `SkipMissedAndDrift(delay_tolerance=timedelta(0))` as the missed tick policy.\n        See the class documentation for details.\n        Args:\n            delay: The time until the timer ticks. Must be at least\n                1 microsecond.\n            auto_start: Whether the timer should be started when the\n                instance is created. This can only be `True` if there is\n                already a running loop or an explicit `loop` that is running\n                was passed.\n            start_delay: The delay before the timer should start. If `auto_start` is\n                `False`, an exception is raised. This has microseconds resolution,\n                anything smaller than a microsecond means no delay.\n            loop: The event loop to use to track time. If `None`,\n                `asyncio.get_running_loop()` will be used.\n        Returns:\n            The timer instance.\n        Raises:\n            RuntimeError: if it was called without a loop and there is no\n                running loop.\n            ValueError: if `interval` is not positive or is smaller than 1\n                microsecond; if `start_delay` is negative or `start_delay` was specified\n                but `auto_start` is `False`.\n        \"\"\"\nreturn Timer(\ndelay,\nSkipMissedAndDrift(delay_tolerance=timedelta(0)),\nauto_start=auto_start,\nstart_delay=start_delay,\nloop=loop,\n)\n@classmethod\ndef periodic(\ncls,\nperiod: timedelta,\n/,\n*,\nskip_missed_ticks: bool = False,\nauto_start: bool = True,\nstart_delay: timedelta = timedelta(0),\nloop: asyncio.AbstractEventLoop | None = None,\n) -&gt; Timer:\n\"\"\"Create a periodic timer.\n        This is basically a shortcut to create a timer with either\n        `TriggerAllMissed()` or `SkipMissedAndResync()` as the missed tick policy\n        (depending on `skip_missed_ticks`).\n        See the class documentation for details.\n        Args:\n            period: The time between timer ticks. Must be at least\n                1 microsecond.\n            skip_missed_ticks: Whether to skip missed ticks or trigger them\n                all until it catches up.\n            auto_start: Whether the timer should be started when the\n                instance is created. This can only be `True` if there is\n                already a running loop or an explicit `loop` that is running\n                was passed.\n            start_delay: The delay before the timer should start. If `auto_start` is\n                `False`, an exception is raised. This has microseconds resolution,\n                anything smaller than a microsecond means no delay.\n            loop: The event loop to use to track time. If `None`,\n                `asyncio.get_running_loop()` will be used.\n        Returns:\n            The timer instance.\n        Raises:\n            RuntimeError: if it was called without a loop and there is no\n                running loop.\n            ValueError: if `interval` is not positive or is smaller than 1\n                microsecond; if `start_delay` is negative or `start_delay` was specified\n                but `auto_start` is `False`.\n        \"\"\"\nmissed_tick_policy = (\nSkipMissedAndResync() if skip_missed_ticks else TriggerAllMissed()\n)\nreturn Timer(\nperiod,\nmissed_tick_policy,\nauto_start=auto_start,\nstart_delay=start_delay,\nloop=loop,\n)\n@property\ndef interval(self) -&gt; timedelta:\n\"\"\"The interval between timer ticks.\n        Returns:\n            The interval between timer ticks.\n        \"\"\"\nreturn timedelta(microseconds=self._interval)\n@property\ndef missed_tick_policy(self) -&gt; MissedTickPolicy:\n\"\"\"The policy of the timer when it misses a tick.\n        Returns:\n            The policy of the timer when it misses a tick.\n        \"\"\"\nreturn self._missed_tick_policy\n@property\ndef loop(self) -&gt; asyncio.AbstractEventLoop:\n\"\"\"The event loop used by the timer to track time.\n        Returns:\n            The event loop used by the timer to track time.\n        \"\"\"\nreturn self._loop\n@property\ndef is_running(self) -&gt; bool:\n\"\"\"Whether the timer is running.\n        This will be `False` if the timer was stopped, or not started yet.\n        Returns:\n            Whether the timer is running.\n        \"\"\"\nreturn not self._stopped\ndef reset(self, *, start_delay: timedelta = timedelta(0)) -&gt; None:\n\"\"\"Reset the timer to start timing from now (plus an optional delay).\n        If the timer was stopped, or not started yet, it will be started.\n        This can only be called with a running loop, see the class documentation for\n        more details.\n        Args:\n            start_delay: The delay before the timer should start. This has microseconds\n                resolution, anything smaller than a microsecond means no delay.\n        Raises:\n            RuntimeError: if it was called without a running loop.\n            ValueError: if `start_delay` is negative.\n        \"\"\"\nstart_delay_ms = _to_microseconds(start_delay)\nif start_delay_ms &lt; 0:\nraise ValueError(f\"`start_delay` can't be negative, got {start_delay}\")\nself._stopped = False\nself._next_tick_time = self._now() + start_delay_ms + self._interval\nself._current_drift = None\ndef stop(self) -&gt; None:\n\"\"\"Stop the timer.\n        Once `stop` has been called, all subsequent calls to `ready()` will\n        immediately return False and calls to `consume()` / `receive()` or any\n        use of the async iterator interface will raise\n        a `ReceiverStoppedError`.\n        You can restart the timer with `reset()`.\n        \"\"\"\nself._stopped = True\n# We need to make sure it's not None, otherwise `ready()` will start it\nself._next_tick_time = self._now()\nasync def ready(self) -&gt; bool:\n\"\"\"Wait until the timer `interval` passed.\n        Once a call to `ready()` has finished, the resulting tick information\n        must be read with a call to `consume()` (`receive()` or iterated over)\n        to tell the timer it should wait for the next interval.\n        The timer will remain ready (this method will return immediately)\n        until it is consumed.\n        Returns:\n            Whether the timer was started and it is still running.\n        Raises:\n            RuntimeError: if it was called without a running loop.\n        \"\"\"\n# If there are messages waiting to be consumed, return immediately.\nif self._current_drift is not None:\nreturn True\n# If `_next_tick_time` is `None`, it means it was created with\n# `auto_start=False` and should be started.\nif self._next_tick_time is None:\nself.reset()\nassert (\nself._next_tick_time is not None\n), \"This should be assigned by reset()\"\n# If a stop was explicitly requested, we bail out.\nif self._stopped:\nreturn False\nnow = self._now()\ntime_to_next_tick = self._next_tick_time - now\n# If we didn't reach the tick yet, sleep until we do.\nif time_to_next_tick &gt; 0:\nawait asyncio.sleep(time_to_next_tick / 1_000_000)\nnow = self._now()\n# If a stop was explicitly requested during the sleep, we bail out.\nif self._stopped:\nreturn False\nself._current_drift = timedelta(microseconds=now - self._next_tick_time)\nself._next_tick_time = self._missed_tick_policy.calculate_next_tick_time(\nnow=now,\nscheduled_tick_time=self._next_tick_time,\ninterval=self._interval,\n)\nreturn True\ndef consume(self) -&gt; timedelta:\n\"\"\"Return the latest drift once `ready()` is complete.\n        Once the timer has triggered (`ready()` is done), this method returns the\n        difference between when the timer should have triggered and the time when\n        it actually triggered. See the class documentation for more details.\n        Returns:\n            The difference between when the timer should have triggered and the\n                time when it actually did.\n        Raises:\n            ReceiverStoppedError: if the timer was stopped via `stop()`.\n        \"\"\"\n# If it was stopped and there it no pending result, we raise\n# (if there is a pending result, then we still want to return it first)\nif self._stopped and self._current_drift is None:\nraise ReceiverStoppedError(self)\nassert (\nself._current_drift is not None\n), \"calls to `consume()` must be follow a call to `ready()`\"\ndrift = self._current_drift\nself._current_drift = None\nreturn drift\ndef _now(self) -&gt; int:\n\"\"\"Return the current monotonic clock time in microseconds.\n        Returns:\n            The current monotonic clock time in microseconds.\n        \"\"\"\nreturn _to_microseconds(self._loop.time())\ndef __str__(self) -&gt; str:\n\"\"\"Return a string representation of the timer.\n        Returns:\n            The string representation of the timer.\n        \"\"\"\nreturn f\"{type(self).__name__}({self.interval})\"\ndef __repr__(self) -&gt; str:\n\"\"\"Return a string representation of the timer.\n        Returns:\n            The string representation of the timer.\n        \"\"\"\nreturn (\nf\"{type(self).__name__}&lt;{self.interval=}, {self.missed_tick_policy=}, \"\nf\"{self.loop=}, {self.is_running=}&gt;\"\n)\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.Timer-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.Timer.interval","title":"<code>interval: timedelta</code>  <code>property</code>","text":"<p>The interval between timer ticks.</p> RETURNS DESCRIPTION <code>timedelta</code> <p>The interval between timer ticks.</p>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.Timer.is_running","title":"<code>is_running: bool</code>  <code>property</code>","text":"<p>Whether the timer is running.</p> <p>This will be <code>False</code> if the timer was stopped, or not started yet.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the timer is running.</p>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.Timer.loop","title":"<code>loop: asyncio.AbstractEventLoop</code>  <code>property</code>","text":"<p>The event loop used by the timer to track time.</p> RETURNS DESCRIPTION <code>AbstractEventLoop</code> <p>The event loop used by the timer to track time.</p>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.Timer.missed_tick_policy","title":"<code>missed_tick_policy: MissedTickPolicy</code>  <code>property</code>","text":"<p>The policy of the timer when it misses a tick.</p> RETURNS DESCRIPTION <code>MissedTickPolicy</code> <p>The policy of the timer when it misses a tick.</p>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.Timer-functions","title":"Functions","text":""},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.Timer.__aiter__","title":"<code>__aiter__()</code>","text":"<p>Initialize the async iterator over received values.</p> RETURNS DESCRIPTION <code>Receiver[T]</code> <p><code>self</code>, since no extra setup is needed for the iterator.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_base_classes.py</code> <pre><code>def __aiter__(self) -&gt; Receiver[T]:\n\"\"\"Initialize the async iterator over received values.\n    Returns:\n        `self`, since no extra setup is needed for the iterator.\n    \"\"\"\nreturn self\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.Timer.__anext__","title":"<code>__anext__()</code>  <code>async</code>","text":"<p>Await the next value in the async iteration over received values.</p> RETURNS DESCRIPTION <code>T</code> <p>The next value received.</p> RAISES DESCRIPTION <code>StopAsyncIteration</code> <p>if the receiver stopped producing messages.</p> <code>ReceiverError</code> <p>if there is some problem with the receiver.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_base_classes.py</code> <pre><code>async def __anext__(self) -&gt; T:\n\"\"\"Await the next value in the async iteration over received values.\n    Returns:\n        The next value received.\n    Raises:\n        StopAsyncIteration: if the receiver stopped producing messages.\n        ReceiverError: if there is some problem with the receiver.\n    \"\"\"\ntry:\nawait self.ready()\nreturn self.consume()\nexcept ReceiverStoppedError as exc:\nraise StopAsyncIteration() from exc\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.Timer.__init__","title":"<code>__init__(interval, missed_tick_policy, /, *, auto_start=True, start_delay=timedelta(0), loop=None)</code>","text":"<p>Create an instance.</p> <p>See the class documentation for details.</p> PARAMETER  DESCRIPTION <code>interval</code> <p>The time between timer ticks. Must be at least 1 microsecond.</p> <p> TYPE: <code>timedelta</code> </p> <code>missed_tick_policy</code> <p>The policy of the timer when it misses a tick. Commonly one of <code>TriggerAllMissed</code>, <code>SkipMissedAndResync</code>, <code>SkipMissedAndDrift</code> or a custom class deriving from <code>MissedTickPolicy</code>. See the documentation of the each class for more details.</p> <p> TYPE: <code>MissedTickPolicy</code> </p> <code>auto_start</code> <p>Whether the timer should be started when the instance is created. This can only be <code>True</code> if there is already a running loop or an explicit <code>loop</code> that is running was passed.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>start_delay</code> <p>The delay before the timer should start. If <code>auto_start</code> is <code>False</code>, an exception is raised. This has microseconds resolution, anything smaller than a microsecond means no delay.</p> <p> TYPE: <code>timedelta</code> DEFAULT: <code>timedelta(0)</code> </p> <code>loop</code> <p>The event loop to use to track time. If <code>None</code>, <code>asyncio.get_running_loop()</code> will be used.</p> <p> TYPE: <code>AbstractEventLoop | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>RuntimeError</code> <p>if it was called without a loop and there is no running loop.</p> <code>ValueError</code> <p>if <code>interval</code> is not positive or is smaller than 1 microsecond; if <code>start_delay</code> is negative or <code>start_delay</code> was specified but <code>auto_start</code> is <code>False</code>.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/util/_timer.py</code> <pre><code>def __init__(\nself,\ninterval: timedelta,\nmissed_tick_policy: MissedTickPolicy,\n/,\n*,\nauto_start: bool = True,\nstart_delay: timedelta = timedelta(0),\nloop: asyncio.AbstractEventLoop | None = None,\n) -&gt; None:\n\"\"\"Create an instance.\n    See the class documentation for details.\n    Args:\n        interval: The time between timer ticks. Must be at least\n            1 microsecond.\n        missed_tick_policy: The policy of the timer when it misses a tick.\n            Commonly one of `TriggerAllMissed`, `SkipMissedAndResync`, `SkipMissedAndDrift`\n            or a custom class deriving from `MissedTickPolicy`. See the\n            documentation of the each class for more details.\n        auto_start: Whether the timer should be started when the\n            instance is created. This can only be `True` if there is\n            already a running loop or an explicit `loop` that is running\n            was passed.\n        start_delay: The delay before the timer should start. If `auto_start` is\n            `False`, an exception is raised. This has microseconds resolution,\n            anything smaller than a microsecond means no delay.\n        loop: The event loop to use to track time. If `None`,\n            `asyncio.get_running_loop()` will be used.\n    Raises:\n        RuntimeError: if it was called without a loop and there is no\n            running loop.\n        ValueError: if `interval` is not positive or is smaller than 1\n            microsecond; if `start_delay` is negative or `start_delay` was specified\n            but `auto_start` is `False`.\n    \"\"\"\nif interval &lt; timedelta(microseconds=1):\nraise ValueError(\nf\"The `interval` must be positive and at least 1 microsecond, not {interval}\"\n)\nif start_delay &gt; timedelta(0) and auto_start is False:\nraise ValueError(\n\"`auto_start` must be `True` if a `start_delay` is specified\"\n)\nself._interval: int = _to_microseconds(interval)\n\"\"\"The time to between timer ticks.\"\"\"\nself._missed_tick_policy: MissedTickPolicy = missed_tick_policy\n\"\"\"The policy of the timer when it misses a tick.\n    See the documentation of `MissedTickPolicy` for details.\n    \"\"\"\nself._loop: asyncio.AbstractEventLoop = (\nloop if loop is not None else asyncio.get_running_loop()\n)\n\"\"\"The event loop to use to track time.\"\"\"\nself._stopped: bool = True\n\"\"\"Whether the timer was requested to stop.\n    If this is `False`, then the timer is running.\n    If this is `True`, then it is stopped or there is a request to stop it\n    or it was not started yet:\n    * If `_next_msg_time` is `None`, it means it wasn't started yet (it was\n      created with `auto_start=False`).  Any receiving method will start\n      it by calling `reset()` in this case.\n    * If `_next_msg_time` is not `None`, it means there was a request to\n      stop it.  In this case receiving methods will raise\n      a `ReceiverClosedError`.\n    \"\"\"\nself._next_tick_time: int | None = None\n\"\"\"The absolute (monotonic) time when the timer should trigger.\n    If this is `None`, it means the timer didn't start yet, but it should\n    be started as soon as it is used.\n    \"\"\"\nself._current_drift: timedelta | None = None\n\"\"\"The difference between `_next_msg_time` and the triggered time.\n    This is calculated by `ready()` but is returned by `consume()`. If\n    `None` it means `ready()` wasn't called and `consume()` will assert.\n    `consume()` will set it back to `None` to tell `ready()` that it needs\n    to wait again.\n    \"\"\"\nif auto_start:\nself.reset(start_delay=start_delay)\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.Timer.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a string representation of the timer.</p> RETURNS DESCRIPTION <code>str</code> <p>The string representation of the timer.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/util/_timer.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Return a string representation of the timer.\n    Returns:\n        The string representation of the timer.\n    \"\"\"\nreturn (\nf\"{type(self).__name__}&lt;{self.interval=}, {self.missed_tick_policy=}, \"\nf\"{self.loop=}, {self.is_running=}&gt;\"\n)\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.Timer.__str__","title":"<code>__str__()</code>","text":"<p>Return a string representation of the timer.</p> RETURNS DESCRIPTION <code>str</code> <p>The string representation of the timer.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/util/_timer.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Return a string representation of the timer.\n    Returns:\n        The string representation of the timer.\n    \"\"\"\nreturn f\"{type(self).__name__}({self.interval})\"\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.Timer.consume","title":"<code>consume()</code>","text":"<p>Return the latest drift once <code>ready()</code> is complete.</p> <p>Once the timer has triggered (<code>ready()</code> is done), this method returns the difference between when the timer should have triggered and the time when it actually triggered. See the class documentation for more details.</p> RETURNS DESCRIPTION <code>timedelta</code> <p>The difference between when the timer should have triggered and the time when it actually did.</p> RAISES DESCRIPTION <code>ReceiverStoppedError</code> <p>if the timer was stopped via <code>stop()</code>.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/util/_timer.py</code> <pre><code>def consume(self) -&gt; timedelta:\n\"\"\"Return the latest drift once `ready()` is complete.\n    Once the timer has triggered (`ready()` is done), this method returns the\n    difference between when the timer should have triggered and the time when\n    it actually triggered. See the class documentation for more details.\n    Returns:\n        The difference between when the timer should have triggered and the\n            time when it actually did.\n    Raises:\n        ReceiverStoppedError: if the timer was stopped via `stop()`.\n    \"\"\"\n# If it was stopped and there it no pending result, we raise\n# (if there is a pending result, then we still want to return it first)\nif self._stopped and self._current_drift is None:\nraise ReceiverStoppedError(self)\nassert (\nself._current_drift is not None\n), \"calls to `consume()` must be follow a call to `ready()`\"\ndrift = self._current_drift\nself._current_drift = None\nreturn drift\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.Timer.into_peekable","title":"<code>into_peekable()</code>","text":"<p>Convert the <code>Receiver</code> implementation into a <code>Peekable</code>.</p> <p>Once this function has been called, the receiver will no longer be usable, and calling <code>receive</code> on the receiver will raise an exception.</p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>when a <code>Receiver</code> implementation doesn't have a custom <code>into_peekable</code> implementation.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_base_classes.py</code> <pre><code>def into_peekable(self) -&gt; Peekable[T]:\n\"\"\"Convert the `Receiver` implementation into a `Peekable`.\n    Once this function has been called, the receiver will no longer be\n    usable, and calling `receive` on the receiver will raise an exception.\n    Raises:\n        NotImplementedError: when a `Receiver` implementation doesn't have\n            a custom `into_peekable` implementation.\n    \"\"\"\nraise NotImplementedError(\"This receiver does not implement `into_peekable`\")\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.Timer.map","title":"<code>map(call)</code>","text":"<p>Return a receiver with <code>call</code> applied on incoming messages.</p> PARAMETER  DESCRIPTION <code>call</code> <p>function to apply on incoming messages.</p> <p> TYPE: <code>Callable[[T], U]</code> </p> RETURNS DESCRIPTION <code>Receiver[U]</code> <p>A <code>Receiver</code> to read results of the given function from.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_base_classes.py</code> <pre><code>def map(self, call: Callable[[T], U]) -&gt; Receiver[U]:\n\"\"\"Return a receiver with `call` applied on incoming messages.\n    Args:\n        call: function to apply on incoming messages.\n    Returns:\n        A `Receiver` to read results of the given function from.\n    \"\"\"\nreturn _Map(self, call)\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.Timer.periodic","title":"<code>periodic(period, /, *, skip_missed_ticks=False, auto_start=True, start_delay=timedelta(0), loop=None)</code>  <code>classmethod</code>","text":"<p>Create a periodic timer.</p> <p>This is basically a shortcut to create a timer with either <code>TriggerAllMissed()</code> or <code>SkipMissedAndResync()</code> as the missed tick policy (depending on <code>skip_missed_ticks</code>).</p> <p>See the class documentation for details.</p> PARAMETER  DESCRIPTION <code>period</code> <p>The time between timer ticks. Must be at least 1 microsecond.</p> <p> TYPE: <code>timedelta</code> </p> <code>skip_missed_ticks</code> <p>Whether to skip missed ticks or trigger them all until it catches up.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>auto_start</code> <p>Whether the timer should be started when the instance is created. This can only be <code>True</code> if there is already a running loop or an explicit <code>loop</code> that is running was passed.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>start_delay</code> <p>The delay before the timer should start. If <code>auto_start</code> is <code>False</code>, an exception is raised. This has microseconds resolution, anything smaller than a microsecond means no delay.</p> <p> TYPE: <code>timedelta</code> DEFAULT: <code>timedelta(0)</code> </p> <code>loop</code> <p>The event loop to use to track time. If <code>None</code>, <code>asyncio.get_running_loop()</code> will be used.</p> <p> TYPE: <code>AbstractEventLoop | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Timer</code> <p>The timer instance.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>if it was called without a loop and there is no running loop.</p> <code>ValueError</code> <p>if <code>interval</code> is not positive or is smaller than 1 microsecond; if <code>start_delay</code> is negative or <code>start_delay</code> was specified but <code>auto_start</code> is <code>False</code>.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/util/_timer.py</code> <pre><code>@classmethod\ndef periodic(\ncls,\nperiod: timedelta,\n/,\n*,\nskip_missed_ticks: bool = False,\nauto_start: bool = True,\nstart_delay: timedelta = timedelta(0),\nloop: asyncio.AbstractEventLoop | None = None,\n) -&gt; Timer:\n\"\"\"Create a periodic timer.\n    This is basically a shortcut to create a timer with either\n    `TriggerAllMissed()` or `SkipMissedAndResync()` as the missed tick policy\n    (depending on `skip_missed_ticks`).\n    See the class documentation for details.\n    Args:\n        period: The time between timer ticks. Must be at least\n            1 microsecond.\n        skip_missed_ticks: Whether to skip missed ticks or trigger them\n            all until it catches up.\n        auto_start: Whether the timer should be started when the\n            instance is created. This can only be `True` if there is\n            already a running loop or an explicit `loop` that is running\n            was passed.\n        start_delay: The delay before the timer should start. If `auto_start` is\n            `False`, an exception is raised. This has microseconds resolution,\n            anything smaller than a microsecond means no delay.\n        loop: The event loop to use to track time. If `None`,\n            `asyncio.get_running_loop()` will be used.\n    Returns:\n        The timer instance.\n    Raises:\n        RuntimeError: if it was called without a loop and there is no\n            running loop.\n        ValueError: if `interval` is not positive or is smaller than 1\n            microsecond; if `start_delay` is negative or `start_delay` was specified\n            but `auto_start` is `False`.\n    \"\"\"\nmissed_tick_policy = (\nSkipMissedAndResync() if skip_missed_ticks else TriggerAllMissed()\n)\nreturn Timer(\nperiod,\nmissed_tick_policy,\nauto_start=auto_start,\nstart_delay=start_delay,\nloop=loop,\n)\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.Timer.ready","title":"<code>ready()</code>  <code>async</code>","text":"<p>Wait until the timer <code>interval</code> passed.</p> <p>Once a call to <code>ready()</code> has finished, the resulting tick information must be read with a call to <code>consume()</code> (<code>receive()</code> or iterated over) to tell the timer it should wait for the next interval.</p> <p>The timer will remain ready (this method will return immediately) until it is consumed.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the timer was started and it is still running.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>if it was called without a running loop.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/util/_timer.py</code> <pre><code>async def ready(self) -&gt; bool:\n\"\"\"Wait until the timer `interval` passed.\n    Once a call to `ready()` has finished, the resulting tick information\n    must be read with a call to `consume()` (`receive()` or iterated over)\n    to tell the timer it should wait for the next interval.\n    The timer will remain ready (this method will return immediately)\n    until it is consumed.\n    Returns:\n        Whether the timer was started and it is still running.\n    Raises:\n        RuntimeError: if it was called without a running loop.\n    \"\"\"\n# If there are messages waiting to be consumed, return immediately.\nif self._current_drift is not None:\nreturn True\n# If `_next_tick_time` is `None`, it means it was created with\n# `auto_start=False` and should be started.\nif self._next_tick_time is None:\nself.reset()\nassert (\nself._next_tick_time is not None\n), \"This should be assigned by reset()\"\n# If a stop was explicitly requested, we bail out.\nif self._stopped:\nreturn False\nnow = self._now()\ntime_to_next_tick = self._next_tick_time - now\n# If we didn't reach the tick yet, sleep until we do.\nif time_to_next_tick &gt; 0:\nawait asyncio.sleep(time_to_next_tick / 1_000_000)\nnow = self._now()\n# If a stop was explicitly requested during the sleep, we bail out.\nif self._stopped:\nreturn False\nself._current_drift = timedelta(microseconds=now - self._next_tick_time)\nself._next_tick_time = self._missed_tick_policy.calculate_next_tick_time(\nnow=now,\nscheduled_tick_time=self._next_tick_time,\ninterval=self._interval,\n)\nreturn True\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.Timer.receive","title":"<code>receive()</code>  <code>async</code>","text":"<p>Receive a message from the channel.</p> RETURNS DESCRIPTION <code>T</code> <p>The received message.</p> RAISES DESCRIPTION <code>ReceiverStoppedError</code> <p>if there is some problem with the receiver.</p> <code>ReceiverError</code> <p>if there is some problem with the receiver.</p>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.Timer.receive--noqa-dar401-cause-httpsgithubcomterrencepreillydarglintissues181","title":"noqa: DAR401 cause (https://github.com/terrencepreilly/darglint/issues/181)","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/_base_classes.py</code> <pre><code>async def receive(self) -&gt; T:\n\"\"\"Receive a message from the channel.\n    Returns:\n        The received message.\n    Raises:\n        ReceiverStoppedError: if there is some problem with the receiver.\n        ReceiverError: if there is some problem with the receiver.\n    # noqa: DAR401 __cause__ (https://github.com/terrencepreilly/darglint/issues/181)\n    \"\"\"\ntry:\nreceived = await self.__anext__()  # pylint: disable=unnecessary-dunder-call\nexcept StopAsyncIteration as exc:\n# If we already had a cause and it was the receiver was stopped,\n# then reuse that error, as StopAsyncIteration is just an artifact\n# introduced by __anext__.\nif (\nisinstance(exc.__cause__, ReceiverStoppedError)\n# pylint is not smart enough to figure out we checked above\n# this is a ReceiverStoppedError and thus it does have\n# a receiver member\nand exc.__cause__.receiver is self  # pylint: disable=no-member\n):\nraise exc.__cause__\nraise ReceiverStoppedError(self) from exc\nreturn received\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.Timer.reset","title":"<code>reset(*, start_delay=timedelta(0))</code>","text":"<p>Reset the timer to start timing from now (plus an optional delay).</p> <p>If the timer was stopped, or not started yet, it will be started.</p> <p>This can only be called with a running loop, see the class documentation for more details.</p> PARAMETER  DESCRIPTION <code>start_delay</code> <p>The delay before the timer should start. This has microseconds resolution, anything smaller than a microsecond means no delay.</p> <p> TYPE: <code>timedelta</code> DEFAULT: <code>timedelta(0)</code> </p> RAISES DESCRIPTION <code>RuntimeError</code> <p>if it was called without a running loop.</p> <code>ValueError</code> <p>if <code>start_delay</code> is negative.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/util/_timer.py</code> <pre><code>def reset(self, *, start_delay: timedelta = timedelta(0)) -&gt; None:\n\"\"\"Reset the timer to start timing from now (plus an optional delay).\n    If the timer was stopped, or not started yet, it will be started.\n    This can only be called with a running loop, see the class documentation for\n    more details.\n    Args:\n        start_delay: The delay before the timer should start. This has microseconds\n            resolution, anything smaller than a microsecond means no delay.\n    Raises:\n        RuntimeError: if it was called without a running loop.\n        ValueError: if `start_delay` is negative.\n    \"\"\"\nstart_delay_ms = _to_microseconds(start_delay)\nif start_delay_ms &lt; 0:\nraise ValueError(f\"`start_delay` can't be negative, got {start_delay}\")\nself._stopped = False\nself._next_tick_time = self._now() + start_delay_ms + self._interval\nself._current_drift = None\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.Timer.stop","title":"<code>stop()</code>","text":"<p>Stop the timer.</p> <p>Once <code>stop</code> has been called, all subsequent calls to <code>ready()</code> will immediately return False and calls to <code>consume()</code> / <code>receive()</code> or any use of the async iterator interface will raise a <code>ReceiverStoppedError</code>.</p> <p>You can restart the timer with <code>reset()</code>.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/util/_timer.py</code> <pre><code>def stop(self) -&gt; None:\n\"\"\"Stop the timer.\n    Once `stop` has been called, all subsequent calls to `ready()` will\n    immediately return False and calls to `consume()` / `receive()` or any\n    use of the async iterator interface will raise\n    a `ReceiverStoppedError`.\n    You can restart the timer with `reset()`.\n    \"\"\"\nself._stopped = True\n# We need to make sure it's not None, otherwise `ready()` will start it\nself._next_tick_time = self._now()\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.Timer.timeout","title":"<code>timeout(delay, /, *, auto_start=True, start_delay=timedelta(0), loop=None)</code>  <code>classmethod</code>","text":"<p>Create a timer useful for tracking timeouts.</p> <p>This is basically a shortcut to create a timer with <code>SkipMissedAndDrift(delay_tolerance=timedelta(0))</code> as the missed tick policy.</p> <p>See the class documentation for details.</p> PARAMETER  DESCRIPTION <code>delay</code> <p>The time until the timer ticks. Must be at least 1 microsecond.</p> <p> TYPE: <code>timedelta</code> </p> <code>auto_start</code> <p>Whether the timer should be started when the instance is created. This can only be <code>True</code> if there is already a running loop or an explicit <code>loop</code> that is running was passed.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>start_delay</code> <p>The delay before the timer should start. If <code>auto_start</code> is <code>False</code>, an exception is raised. This has microseconds resolution, anything smaller than a microsecond means no delay.</p> <p> TYPE: <code>timedelta</code> DEFAULT: <code>timedelta(0)</code> </p> <code>loop</code> <p>The event loop to use to track time. If <code>None</code>, <code>asyncio.get_running_loop()</code> will be used.</p> <p> TYPE: <code>AbstractEventLoop | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Timer</code> <p>The timer instance.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>if it was called without a loop and there is no running loop.</p> <code>ValueError</code> <p>if <code>interval</code> is not positive or is smaller than 1 microsecond; if <code>start_delay</code> is negative or <code>start_delay</code> was specified but <code>auto_start</code> is <code>False</code>.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/util/_timer.py</code> <pre><code>@classmethod\ndef timeout(\ncls,\ndelay: timedelta,\n/,\n*,\nauto_start: bool = True,\nstart_delay: timedelta = timedelta(0),\nloop: asyncio.AbstractEventLoop | None = None,\n) -&gt; Timer:\n\"\"\"Create a timer useful for tracking timeouts.\n    This is basically a shortcut to create a timer with\n    `SkipMissedAndDrift(delay_tolerance=timedelta(0))` as the missed tick policy.\n    See the class documentation for details.\n    Args:\n        delay: The time until the timer ticks. Must be at least\n            1 microsecond.\n        auto_start: Whether the timer should be started when the\n            instance is created. This can only be `True` if there is\n            already a running loop or an explicit `loop` that is running\n            was passed.\n        start_delay: The delay before the timer should start. If `auto_start` is\n            `False`, an exception is raised. This has microseconds resolution,\n            anything smaller than a microsecond means no delay.\n        loop: The event loop to use to track time. If `None`,\n            `asyncio.get_running_loop()` will be used.\n    Returns:\n        The timer instance.\n    Raises:\n        RuntimeError: if it was called without a loop and there is no\n            running loop.\n        ValueError: if `interval` is not positive or is smaller than 1\n            microsecond; if `start_delay` is negative or `start_delay` was specified\n            but `auto_start` is `False`.\n    \"\"\"\nreturn Timer(\ndelay,\nSkipMissedAndDrift(delay_tolerance=timedelta(0)),\nauto_start=auto_start,\nstart_delay=start_delay,\nloop=loop,\n)\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.TriggerAllMissed","title":"<code>frequenz.channels.util.TriggerAllMissed</code>","text":"<p>             Bases: <code>MissedTickPolicy</code></p> <p>A policy that triggers all the missed ticks immediately until it catches up.</p> Example <p>Assume a timer with interval 1 second, the tick <code>T0</code> happens exactly at time 0, the second tick, <code>T1</code>, happens at time 1.2 (0.2 seconds late), so it trigges immediately.  The third tick, <code>T2</code>, happens at time 2.3 (0.3 seconds late), so it also triggers immediately.  The fourth tick, <code>T3</code>, happens at time 4.3 (1.3 seconds late), so it also triggers immediately as well as the fifth tick, <code>T4</code>, which was also already delayed (by 0.3 seconds), so it catches up.  The sixth tick, <code>T5</code>, happens at 5.1 (0.1 seconds late), so it triggers immediately again. The seventh tick, <code>T6</code>, happens at 6.0, right on time.</p> <pre><code>0         1         2         3         4  o      5         6\no---------|-o-------|--o------|---------|--o------|o--------o-----&gt; time\nT0          T1         T2                  T3      T5       T6\n                                           T4\n</code></pre> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/util/_timer.py</code> <pre><code>class TriggerAllMissed(MissedTickPolicy):\n\"\"\"A policy that triggers all the missed ticks immediately until it catches up.\n    Example:\n        Assume a timer with interval 1 second, the tick `T0` happens exactly\n        at time 0, the second tick, `T1`, happens at time 1.2 (0.2 seconds\n        late), so it trigges immediately.  The third tick, `T2`, happens at\n        time 2.3 (0.3 seconds late), so it also triggers immediately.  The\n        fourth tick, `T3`, happens at time 4.3 (1.3 seconds late), so it also\n        triggers immediately as well as the fifth tick, `T4`, which was also\n        already delayed (by 0.3 seconds), so it catches up.  The sixth tick,\n        `T5`, happens at 5.1 (0.1 seconds late), so it triggers immediately\n        again. The seventh tick, `T6`, happens at 6.0, right on time.\n        ```\n        0         1         2         3         4  o      5         6\n        o---------|-o-------|--o------|---------|--o------|o--------o-----&gt; time\n        T0          T1         T2                  T3      T5       T6\n                                                   T4\n        ```\n    \"\"\"\ndef calculate_next_tick_time(\nself, *, now: int, scheduled_tick_time: int, interval: int\n) -&gt; int:\n\"\"\"Calculate the next tick time.\n        This method always returns `scheduled_tick_time + interval`, as all\n        ticks need to produce a trigger event.\n        Args:\n            now: The current loop time (in microseconds).\n            scheduled_tick_time: The time the current tick was scheduled to\n                trigger (in microseconds).\n            interval: The interval between ticks (in microseconds).\n        Returns:\n            The next tick time (in microseconds).\n        \"\"\"\nreturn scheduled_tick_time + interval\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.TriggerAllMissed-functions","title":"Functions","text":""},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.TriggerAllMissed.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a string representation of the instance.</p> RETURNS DESCRIPTION <code>str</code> <p>The string representation of the instance.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/util/_timer.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Return a string representation of the instance.\n    Returns:\n        The string representation of the instance.\n    \"\"\"\nreturn f\"{type(self).__name__}()\"\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.TriggerAllMissed.calculate_next_tick_time","title":"<code>calculate_next_tick_time(*, now, scheduled_tick_time, interval)</code>","text":"<p>Calculate the next tick time.</p> <p>This method always returns <code>scheduled_tick_time + interval</code>, as all ticks need to produce a trigger event.</p> PARAMETER  DESCRIPTION <code>now</code> <p>The current loop time (in microseconds).</p> <p> TYPE: <code>int</code> </p> <code>scheduled_tick_time</code> <p>The time the current tick was scheduled to trigger (in microseconds).</p> <p> TYPE: <code>int</code> </p> <code>interval</code> <p>The interval between ticks (in microseconds).</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>int</code> <p>The next tick time (in microseconds).</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/util/_timer.py</code> <pre><code>def calculate_next_tick_time(\nself, *, now: int, scheduled_tick_time: int, interval: int\n) -&gt; int:\n\"\"\"Calculate the next tick time.\n    This method always returns `scheduled_tick_time + interval`, as all\n    ticks need to produce a trigger event.\n    Args:\n        now: The current loop time (in microseconds).\n        scheduled_tick_time: The time the current tick was scheduled to\n            trigger (in microseconds).\n        interval: The interval between ticks (in microseconds).\n    Returns:\n        The next tick time (in microseconds).\n    \"\"\"\nreturn scheduled_tick_time + interval\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.UnhandledSelectedError","title":"<code>frequenz.channels.util.UnhandledSelectedError</code>","text":"<p>             Bases: <code>SelectError</code>, <code>Generic[_T]</code></p> <p>A receiver was not handled in a <code>select()</code> loop.</p> <p>This exception is raised when a <code>select()</code> iteration finishes without a call to <code>selected_from()</code> for the selected receiver.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/util/_select.py</code> <pre><code>class UnhandledSelectedError(SelectError, Generic[_T]):\n\"\"\"A receiver was not handled in a [`select()`][frequenz.channels.util.select] loop.\n    This exception is raised when a `select()` iteration finishes without a call to\n    [`selected_from()`][frequenz.channels.util.selected_from] for the selected receiver.\n    \"\"\"\ndef __init__(self, selected: Selected[_T]) -&gt; None:\n\"\"\"Create a new instance.\n        Args:\n            selected: The selected receiver that was not handled.\n        \"\"\"\nrecv = selected._recv  # pylint: disable=protected-access\nsuper().__init__(f\"Selected receiver {recv} was not handled in the if-chain\")\nself.selected = selected\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.UnhandledSelectedError-functions","title":"Functions","text":""},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.UnhandledSelectedError.__init__","title":"<code>__init__(selected)</code>","text":"<p>Create a new instance.</p> PARAMETER  DESCRIPTION <code>selected</code> <p>The selected receiver that was not handled.</p> <p> TYPE: <code>Selected[_T]</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/util/_select.py</code> <pre><code>def __init__(self, selected: Selected[_T]) -&gt; None:\n\"\"\"Create a new instance.\n    Args:\n        selected: The selected receiver that was not handled.\n    \"\"\"\nrecv = selected._recv  # pylint: disable=protected-access\nsuper().__init__(f\"Selected receiver {recv} was not handled in the if-chain\")\nself.selected = selected\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util-functions","title":"Functions","text":""},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.select","title":"<code>frequenz.channels.util.select(*receivers)</code>  <code>async</code>","text":"<p>Iterate over the values of all receivers as they receive new values.</p> <p>This function is used to iterate over the values of all receivers as they receive new values.  It is used in conjunction with the <code>Selected</code> class and the <code>selected_from()</code> function to determine which function to determine which receiver was selected in a select operation.</p> <p>An exhaustiveness check is performed at runtime to make sure all selected receivers are handled in the if-chain, so you should call <code>selected_from()</code> with all the receivers passed to <code>select()</code> inside the select loop, even if you plan to ignore a value, to signal <code>select()</code> that you are purposefully ignoring the value.</p> Note <p>The <code>select()</code> function is intended to be used in cases where the set of receivers is static and known beforehand.  If you need to dynamically add/remove receivers from a select loop, there are a few alternatives.  Depending on your use case, one or the other could work better for you:</p> <ul> <li>Use <code>Merge</code> or   <code>MergeNamed</code>: this is useful when you   have and unknown number of receivers of the same type that can be handled as   a group.</li> <li>Use tasks to manage each receiver individually: this is better if there are no   relationships between the receivers.</li> <li>Break the <code>select()</code> loop and start a new one with the new set of receivers   (this should be the last resort, as it has some performance implications    because the loop needs to be restarted).</li> </ul> Example <pre><code>import datetime\nfrom typing import assert_never\nfrom frequenz.channels import ReceiverStoppedError\nfrom frequenz.channels.util import select, selected_from, Timer\ntimer1 = Timer.periodic(datetime.timedelta(seconds=1))\ntimer2 = Timer.timeout(datetime.timedelta(seconds=0.5))\nasync for selected in select(timer1, timer2):\nif selected_from(selected, timer1):\n# Beware: `selected.value` might raise an exception, you can always\n# check for exceptions with `selected.exception` first or use\n# a try-except block. You can also quickly check if the receiver was\n# stopped and let any other unexpected exceptions bubble up.\nif selected.was_stopped:\nprint(\"timer1 was stopped\")\ncontinue\nprint(f\"timer1: now={datetime.datetime.now()} drift={selected.value}\")\ntimer2.stop()\nelif selected_from(selected, timer2):\n# Explicitly handling of exceptions\nmatch selected.exception:\ncase ReceiverStoppedError():\nprint(\"timer2 was stopped\")\ncase Exception() as exception:\nprint(f\"timer2: exception={exception}\")\ncase None:\n# All good, no exception, we can use `selected.value` safely\nprint(\nf\"timer2: now={datetime.datetime.now()} drift={selected.value}\"\n)\ncase _ as unhanded:\nassert_never(unhanded)\nelse:\n# This is not necessary, as select() will check for exhaustiveness, but\n# it is good practice to have it in case you forgot to handle a new\n# receiver added to `select()` at a later point in time.\nassert False\n</code></pre> PARAMETER  DESCRIPTION <code>*receivers</code> <p>The receivers to select from.</p> <p> TYPE: <code>Receiver[Any]</code> DEFAULT: <code>()</code> </p> YIELDS DESCRIPTION <code>AsyncIterator[Selected[Any]]</code> <p>The currently selected item.</p> RAISES DESCRIPTION <code>UnhandledSelectedError</code> <p>If a selected receiver was not handled in the if-chain.</p> <code>SelectErrorGroup</code> <p>If there is an error while finishing the select operation and receivers fail while cleaning up.</p> <code>SelectError</code> <p>If there is an error while selecting receivers during normal operation.  For example if a receiver raises an exception in the <code>ready()</code> method.  Normal errors while receiving values are not raised, but reported via the <code>Selected</code> instance.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/util/_select.py</code> <pre><code>async def select(*receivers: Receiver[Any]) -&gt; AsyncIterator[Selected[Any]]:\n\"\"\"Iterate over the values of all receivers as they receive new values.\n    This function is used to iterate over the values of all receivers as they receive\n    new values.  It is used in conjunction with the\n    [`Selected`][frequenz.channels.util.Selected] class and the\n    [`selected_from()`][frequenz.channels.util.selected_from] function to determine\n    which function to determine which receiver was selected in a select operation.\n    An exhaustiveness check is performed at runtime to make sure all selected receivers\n    are handled in the if-chain, so you should call `selected_from()` with all the\n    receivers passed to `select()` inside the select loop, even if you plan to ignore\n    a value, to signal `select()` that you are purposefully ignoring the value.\n    Note:\n        The `select()` function is intended to be used in cases where the set of\n        receivers is static and known beforehand.  If you need to dynamically add/remove\n        receivers from a select loop, there are a few alternatives.  Depending on your\n        use case, one or the other could work better for you:\n        * Use [`Merge`][frequenz.channels.util.Merge] or\n          [`MergeNamed`][frequenz.channels.util.MergeNamed]: this is useful when you\n          have and unknown number of receivers of the same type that can be handled as\n          a group.\n        * Use tasks to manage each receiver individually: this is better if there are no\n          relationships between the receivers.\n        * Break the `select()` loop and start a new one with the new set of receivers\n          (this should be the last resort, as it has some performance implications\n           because the loop needs to be restarted).\n    Example:\n        ```python\n        import datetime\n        from typing import assert_never\n        from frequenz.channels import ReceiverStoppedError\n        from frequenz.channels.util import select, selected_from, Timer\n        timer1 = Timer.periodic(datetime.timedelta(seconds=1))\n        timer2 = Timer.timeout(datetime.timedelta(seconds=0.5))\n        async for selected in select(timer1, timer2):\n            if selected_from(selected, timer1):\n                # Beware: `selected.value` might raise an exception, you can always\n                # check for exceptions with `selected.exception` first or use\n                # a try-except block. You can also quickly check if the receiver was\n                # stopped and let any other unexpected exceptions bubble up.\n                if selected.was_stopped:\n                    print(\"timer1 was stopped\")\n                    continue\n                print(f\"timer1: now={datetime.datetime.now()} drift={selected.value}\")\n                timer2.stop()\n            elif selected_from(selected, timer2):\n                # Explicitly handling of exceptions\n                match selected.exception:\n                    case ReceiverStoppedError():\n                        print(\"timer2 was stopped\")\n                    case Exception() as exception:\n                        print(f\"timer2: exception={exception}\")\n                    case None:\n                        # All good, no exception, we can use `selected.value` safely\n                        print(\n                            f\"timer2: now={datetime.datetime.now()} drift={selected.value}\"\n                        )\n                    case _ as unhanded:\n                        assert_never(unhanded)\n            else:\n                # This is not necessary, as select() will check for exhaustiveness, but\n                # it is good practice to have it in case you forgot to handle a new\n                # receiver added to `select()` at a later point in time.\n                assert False\n        ```\n    Args:\n        *receivers: The receivers to select from.\n    Yields:\n        The currently selected item.\n    Raises:\n        UnhandledSelectedError: If a selected receiver was not handled in the if-chain.\n        SelectErrorGroup: If there is an error while finishing the select operation and\n            receivers fail while cleaning up.\n        SelectError: If there is an error while selecting receivers during normal\n            operation.  For example if a receiver raises an exception in the `ready()`\n            method.  Normal errors while receiving values are not raised, but reported\n            via the `Selected` instance.\n    \"\"\"\nreceivers_map: dict[str, Receiver[Any]] = {str(hash(r)): r for r in receivers}\npending: set[asyncio.Task[bool]] = set()\ntry:\nfor name, recv in receivers_map.items():\npending.add(asyncio.create_task(recv.ready(), name=name))\nwhile pending:\ndone, pending = await asyncio.wait(\npending, return_when=asyncio.FIRST_COMPLETED\n)\nfor task in done:\nreceiver_active: bool = True\nname = task.get_name()\nrecv = receivers_map[name]\nif exception := task.exception():\nmatch exception:\ncase asyncio.CancelledError():\n# If the receiver was cancelled, then it means we want to\n# exit the select loop, so we handle the receiver but we\n# don't add it back to the pending list.\nreceiver_active = False\ncase _ as exc:\nraise SelectError(f\"Error while selecting {recv}\") from exc\nselected = Selected(recv)\nyield selected\nif not selected._handled:  # pylint: disable=protected-access\nraise UnhandledSelectedError(selected)\nreceiver_active = task.result()\nif not receiver_active:\ncontinue\n# Add back the receiver to the pending list\nname = task.get_name()\nrecv = receivers_map[name]\npending.add(asyncio.create_task(recv.ready(), name=name))\nfinally:\nawait _stop_pending_tasks(pending)\n</code></pre>"},{"location":"reference/frequenz/channels/util/#frequenz.channels.util.selected_from","title":"<code>frequenz.channels.util.selected_from(selected, receiver)</code>","text":"<p>Check if the given receiver was selected by <code>select()</code>.</p> <p>This function is used in conjunction with the <code>Selected</code> class to determine which receiver was selected in <code>select()</code> iteration.</p> <p>It also works as a type guard to narrow the type of the <code>Selected</code> instance to the type of the receiver.</p> <p>Please see <code>select()</code> for an example.</p> PARAMETER  DESCRIPTION <code>selected</code> <p>The result of a <code>select()</code> iteration.</p> <p> TYPE: <code>Selected[Any]</code> </p> <code>receiver</code> <p>The receiver to check if it was the source of a select operation.</p> <p> TYPE: <code>Receiver[_T]</code> </p> RETURNS DESCRIPTION <code>TypeGuard[Selected[_T]]</code> <p>Whether the given receiver was selected.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/channels/util/_select.py</code> <pre><code>def selected_from(\nselected: Selected[Any], receiver: Receiver[_T]\n) -&gt; TypeGuard[Selected[_T]]:\n\"\"\"Check if the given receiver was selected by [`select()`][frequenz.channels.util.select].\n    This function is used in conjunction with the\n    [`Selected`][frequenz.channels.util.Selected] class to determine which receiver was\n    selected in `select()` iteration.\n    It also works as a [type guard][typing.TypeGuard] to narrow the type of the\n    `Selected` instance to the type of the receiver.\n    Please see [`select()`][frequenz.channels.util.select] for an example.\n    Args:\n        selected: The result of a `select()` iteration.\n        receiver: The receiver to check if it was the source of a select operation.\n    Returns:\n        Whether the given receiver was selected.\n    \"\"\"\nif handled := selected._recv is receiver:  # pylint: disable=protected-access\nselected._handled = True  # pylint: disable=protected-access\nreturn handled\n</code></pre>"}]}